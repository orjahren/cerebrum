#! /usr/bin/env python
# -*- coding: utf-8 -*-

# Copyright 2004 University of Oslo, Norway
#
# This file is part of Cerebrum.
#
# Cerebrum is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Cerebrum is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Cerebrum; if not, write to the Free Software Foundation,
# Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

# Global imports
from __future__ import unicode_literals
import getopt
import sys
import os
import mx.DateTime
import datetime
import  xml.sax
import libxml2
import time
import string
from pprint import pprint

# Cerebrum imports
import cerebrum_path
import cereconf
from Cerebrum import Utils
from Cerebrum.Utils import Factory
from Cerebrum.modules.no.uit.sito_utils import sitoFactory
from Cerebrum import Errors
from Cerebrum.modules.no import fodselsnr
from Cerebrum.modules.no.Person import PersonFnrMixin
#from Cerebrum.modules.no.EntityExpire import EntityExpire
from Cerebrum.modules.no.uit.EntityExpire import EntityExpire
from Cerebrum.modules.no.uit.EntityExpire import EntityExpiredError




# Global variables
progname = __file__.split(os.sep)[-1]
db = Factory.get('Database')()
db.cl_init(change_program=progname)
const = Factory.get('Constants')(db)
ou = sitoFactory.get('sito_ou')(db)
person = Factory.get('Person')(db)
new_person = Factory.get('Person')(db)
e = Factory.get('Entity')(db)


#sito_fac = Factory()
#sito_fac.components['SITO_OU'] = 'CLASS_SITO_OU'
#sito = 

#init the logger.
logger = Factory.get_logger(cereconf.DEFAULT_LOGGER_TARGET)
#initiate global datetime for today
TODAY=mx.DateTime.today().strftime("%Y-%m-%d")

# Doc string
__doc__="""

    import_sito.py can import person and/or ou data into BAS.
    the person and ou files are xml files generated by SITO HR systems
    

    usage:: %s [-p <filename> | -o <filename>] [-d] [--logger-name= [console | cronjob]]

    options:
       [--logger-name                - where to log
       [-p|--person_file <filename>] - person file 
       [-o|--ou_file] <filename>     - ou file
       [-d|--dryrun]                 - do not write to database
       [-h|--help]                   - this text
""" % (progname)





def load_all_affi_entry():
    affi_list = {}
    for row in new_person.list_affiliations(source_system=const.system_sito):
        key_l = "%s:%s:%s" % (row['person_id'],row['ou_id'],row['affiliation'])
        affi_list[key_l] = True
    return(affi_list)



def clean_affi_s_list():
    for k,v in cere_list.items():
        if v:
            [ent_id,ou,affi] = [int(x) for x in k.split(':')]
            new_person.clear()
            new_person.entity_id = int(ent_id)
            affs=new_person.list_affiliations(ent_id,affiliation=affi,ou_id=ou,source_system=const.system_sito)
            for aff in affs:
                last_date = datetime.datetime.fromtimestamp(aff['last_date'])
                end_grace_period = last_date +\
                    datetime.timedelta(days=cereconf.GRACEPERIOD_EMPLOYEE_SITO)
                if datetime.datetime.today() > end_grace_period:
                    logger.warn("Deleting system_sito affiliation for " \
                    "person_id=%s,ou=%s,affi=%s last_date=%s,grace=%s" % \
                        (ent_id,ou,affi,last_date,cereconf.GRACEPERIOD_EMPLOYEE_SITO))
                    new_person.delete_affiliation(ou, affi, const.system_sito)


#
# import SITO persons into BAS
#
def import_person(person_list):

    ######################################################################################
    #
    # Persons (from person_list) being processed in this function will have the following variables
    #
    # ssn = 11 digit | ''
    # gender = Male/Female | ''
    # Birthdate = YYYY-MM-DDT00:00:00
    # Firstname = somename
    # Lastname = somename
    # countrycode = NN | ''
    # postalarea = someaddress | ''
    # streetname = somestreet | ''
    # zipcode = somezipcode | ''
    # employmentnumber = somenumber
    # positioncode = somenumber | ''
    # positionname = somename | '' 
    # affiliation = some_organization_id
    #
    ######################################################################################

    
    for person in person_list:
        ssn_is_missing = False
        ssn_not_valid = False
        valid_birthdate = True
        person_processed = {}

        logger.info("--- Processing employee number:%s ---" %(person['EmploymentNumber']))

        #
        # Get Person Birthdate
        #
        try:
            person_processed['birth_year'] = int(person['Birthdate'][0:4])
            person_processed['birth_month']= int(person['Birthdate'][5:7])
            person_processed['birth_day'] = int(person['Birthdate'][8:10])
        except ValueError:
            valid_birthdate = False
            logger.warning("Empty Birthdate string for employee number:%s." %person['EmploymentNumber'])
            
        #
        # check if SSN is registered and valid
        #
        try:
            fodselsnr.personnr_ok(person['Ssn'])
            person_processed['ssn'] = person['Ssn']
        except fodselsnr.InvalidFnrError:
            logger.warning("Empty SSN for employee number:%s" % (person['EmploymentNumber']))
            ssn_not_valid = True
            person_processed['ssn']=''


        #
        # set person gender (checking both SSN and gender from sito input file)
        #
        gender = const.gender_male
        if(ssn_not_valid == False):
            if fodselsnr.er_kvinne(person['Ssn']):
                gender = const.gender_female
        elif(gender != person['Gender'][0] == 'F'):
            # ssn is not valid. use Gender variable from sito import file instead.
            gender = const.gender_female
        else:
            # person has neither ssn nor gender set in import file. impossible to set gender.
            logger.warning("impossible to set gender for employee number:%s. using Unknown" % person['EmploymentNumber'])
            gender = const.gender_unknown
            

        person_processed['gender'] = gender

        #
        # Validate Birthdate against SSN
        #
        if((ssn_not_valid == False) and (valid_birthdate == True)):
            (year_check,month_check,day_check) = fodselsnr.fodt_dato(person['Ssn'])
            # person has ssn and birthdate. verify the data
            if year_check != person_processed['birth_year']:
                logger.warn("Year inconsistent between XML (%s) and FNR (%s) for employee:%s" % (person_processed['birth_year'], year_check, person['EmploymentNumber']))
                continue
            if month_check != person_processed['birth_month']:
                logger.warn("Month inconsistent between XML (%s) and FNR (%s) for employee %s" % (person_processed['birth_month'], mon_check, person['EmploymentNumber']))
                continue
            if day_check != person_processed['birth_day']:
                logger.warn("Day inconsistent between XML (%s) and FNR (%s) for person %s" % (person_processed['birth_day'], day_check, person['EmploymentNumber']))
                continue
        elif((ssn_not_valid == False) and (valid_birthdate == False)):
            # person has ssn but not birthdate. set birthdate based on ssn.
            logger.warn("person:%s is missing birthdate. Setting it based on SSN" % (person['Ssn']))
            if( fodselsnr.personnr_ok(person['Ssn'])):
                year,mon,day = fodselsnr.fodt_dato(person['Ssn'])
                #print "year:%s, mon:%s, day:%s" % (year,mon,day)
                person_processed['birth_year'] = year
                person_processed['birth_month'] = mon
                person_processed['birth_day'] = day
            else:
                continue
            
        elif((valid_birthdate == True) and (ssn_not_valid == True)):
            #person have birthdate but NOT ssn. Nothing to do here
            pass
            
        elif((valid_birthdate == False) and (ssn_not_valid == True)):
            #person does not have birthdate nor ssn. This person cannot be built.
            #SSN or Birthdate required. Return error message and continue with NEXT person
            logger.warn("Employee number: %s is missing SSN and Birthdate. NOT imported" %(person['EmploymentNumber']))
            continue


        #################################################
        # collect various person data from person list  #
        #################################################


        person_processed['ansattnr'] = person['EmploymentNumber']
        person_processed['Firstname'] = person['Firstname']
        person_processed['Lastname'] = person['Lastname']
        person_processed['PositionName'] = person['PositionName']
        person_processed['title'] = person['title']
        try:
            person['Middlename']
            person_processed['Middlename'] = person['Middlename']
        except KeyError:
            # person has no middle name. do nothing
            pass

        #
        # Get person object som DB if it exists
        #

        new_person.clear()
        existing_person = False
        try:
            new_person.find_by_external_id(const.externalid_sito_ansattnr,person_processed['ansattnr'])
            existing_person = True
            #logger.error("found person_id:%s with ansattnr:%s" % (new_person.entity_id,person_processed['ansattnr']))
        except Errors.NotFoundError:
            # could not find person in DB based on ansattnr.
            if(ssn_not_valid == False):
                # tro to find person using ssn if ssn is valid
                try:
                    new_person.clear()
                    new_person.find_by_external_id(const.externalid_fodselsnr,person_processed['ssn'])
                    existing_person = True
                    #logger.error("found person_id:%s with fnr:%s" % (new_person.entity_id,person_processed['ansattnr']))
                except Errors.NotFoundError:
                    # Could not find person in DB based on fnr
                    logger.info("-- Create new person object for ssn:%s --" % (person_processed['ssn']))
                    pass
            
        if((person_processed['Firstname'].isspace() == True )or (person_processed['Lastname'].isspace() == True)):
            # Firstname and/or lastname is made of whitespace ONLY.
            # generate error message and continue with NEXT person
            logger.error("missing first and/or lastname for person:%s. Person NOT imported" % person)
            continue

        if(existing_person == True):
            #logger.debug("person with entity_id:%s already exists in the Database" %(new_person.entity_id))
            pass

        #
        # Populate the person object
        #
        try:
            new_person.populate(mx.DateTime.Date(person_processed['birth_year'], person_processed['birth_month'],person_processed['birth_day']), gender)
        except Errors.CerebrumError,m:
            logger.error("Person: %s populate failed: %s" %(person_processed['ssn'] or person_processed['ansattnr'],m))
            # population of person object failes. Continue
            continue
        new_person.affect_names(const.system_sito, const.name_first, const.name_last, const.name_work_title)
        new_person.affect_external_id(const.system_sito, const.externalid_fodselsnr, const.externalid_sito_ansattnr)
        try:
            person_processed['Middlename']
            concat_firstname = "%s %s" % (person_processed['Firstname'],person_processed['Middlename'])
            person_processed['Firstname'] = concat_firstname
            logger.debug("CONCAT FIRSTNAME:%s" % person_processed['Firstname'])
        except KeyError:
            # person has no middlename. use original firstname
            pass
        new_person.populate_name(const.name_first, person_processed['Firstname'])
        new_person.populate_name(const.name_last, person_processed['Lastname'])

        logger.warning("person_processed title is:%s" % person_processed['title'])
        if(person_processed['title'] != ''):
            new_person.populate_name(const.name_work_title, person_processed['title'])
        if(person_processed['ssn'] != ''):
            new_person.populate_external_id(const.system_sito, const.externalid_fodselsnr, person_processed['ssn'])
            logger.info("setting external_id to:%s" %(person_processed['ssn']))
        new_person.populate_external_id(const.system_sito, const.externalid_sito_ansattnr, person_processed['ansattnr'])
        
        # In case this is a new person, we will need to write to DB before we can continue.
        op = new_person.write_db()

        #new_person.affect_names(const.system_sito, const.name_work_title)
        #print "##PERSON##"
        #pprint(person)
        affiliation = determine_affiliations(person)
        new_person.populate_affiliation(const.system_sito)
        contact = determine_contact(person)
        new_person.populate_contact_info(const.system_sito)

        # set person affiliation
        for k,v in affiliation.items():
            ou_id, aff, aff_stat = v
            logger.info("Has affiliation %s towards ou:%s" % (aff_stat,ou_id))
            new_person.populate_affiliation(const.system_sito, ou_id, int(aff), int(aff_stat))
            #new_person.add_affiliation(ou_id, int(aff), const.system_sito, int(aff_stat))

            # set this persons affiliation entry to False
            # this ensures that this persons affiliations will not be removed when the clean_affiliation function is called
            # after import person
            if cere_list.has_key(k):
                cere_list[k] = False


        # get person work, cellular and home phone numbers
        c_prefs = {}
        for con,number in contact.items():
            if(con == 'Cellphone'):
                c_type = int(const.contact_mobile_phone)
            if(con == 'Home'):
                c_type = int(const.contact_phone_private)
            if(con == 'Work'):
                c_type = int(const.contact_phone)
            pref = c_prefs.get(c_type,0)                        
            new_person.populate_contact_info(const.system_sito, c_type, number, pref)
            logger.debug("system:%s, c_type:%s, number:%s, pref:%s" %(const.system_sito, c_type, number, pref))
            pref = c_prefs[c_type] = pref = 1

        op2 = new_person.write_db()
        # set affiliation last seen date
        for k,v in affiliation.items():
            ou_id, aff, aff_stat = v
            new_person.set_affiliation_last_date(const.system_sito, ou_id, int(aff), int(aff_stat))
        op2 = new_person.write_db()
        logger.info("WriteDB after affs: %s" % (op2,))


def determine_contact(person):
    phone_info = {}
    test_dict = {}
    phone = string.split(person['Phone'],',')
    for single_phone in phone:
        single_phone = single_phone.strip()
        if(len(single_phone) > 0):  
            # append each phone type to returning object
            type,number = single_phone.split(":")
            phone_info[type] = number            
    return phone_info


#
# Get ou_id based on external_id
#
def get_ou(a,person):
    
    external_id = a.split(",")
    
    for single_id in external_id:
        ou.clear()
        try:
            ou.find_by_external_id(id_type=const.externalid_sito_ou, external_id=single_id, source_system=const.system_sito, entity_type=const.entity_ou)
        except EntityExpiredError:
            # person registered to expired OU. return error message.
            logger.error("person:%s is registered to expired OU with external_id:%s" % (person['Ssn'],single_id))
            return -1
        except Errors.NotFoundError:
            logger.error("WARNING - person:%s %s is registered to a nonexistin OU with external id:%s" %(person['Firstname'],person['Lastname'],single_id))
            return -1

        if(single_id == cereconf.DEFAULT_SITO_ROOT_HASH):
            logger.info("person:%s has affiliation to SITO root node" % person['Ssn'])
#            return -1
        return(ou.entity_id)


#
# will return a list of:
# ou_id              - organizational ID
# affiliation        - Ansatt
# affiliation type   - (tekadn,adm)
#
# For all person affiliations
#
def determine_affiliations(person):
    ret = {}
    # percentage = []
    aff = const.affiliation_ansatt_sito
    aff_stat =''
    #pprint(person['Affiliation'])
    t = person['Affiliation'].split(",")
    for a in t:
        position_type = person['Employment_description']
        aff_stat = const.affiliation_status_ansatt_sito
        ou = get_ou(a,person)
        if(ou == -1):
            # unable to find OU.
            logger.error("Got -1 from get_ou %s" % a)
            continue
        else:
            # valid ou id found. continue processing
            k = "%s:%s:%s" % (new_person.entity_id,ou,int(aff))
            if not ret.has_key(k):
                ret[k]= ou,const.affiliation_ansatt_sito,aff_stat
    #pprint(ret)
    return(ret)


#
# Generate person data from SITO person file.
#
# Required attributes are (withouth these person will not be imported):
#
#   SSN
#   EmploymentNumber
#   Firstname
#   Lastname
#   Affiliation
#   IsDeactivated
#
def generate_person_list(personfile,person_list):

    if(os.path.isfile(personfile) == False):
        logger.error("File:%s does not exist. Exiting" % personfile)
        sys.exit(1)

    #
    #
    #


    datafile = libxml2.parseFile(personfile)
    ctxt = datafile.xpathNewContext()
    


    #
    # Parse person xml file and get all relevant person data
    #
    for person in ctxt.xpathEval("//Persons/Person"):
        person_dict = {}
        ctxt.setContextNode(person)


        #
        # Get Person data from person xml file. In cases where data is missing the
        # relevant person_dict['somename'] value will be set to an empty string
        #
        try:
            person_dict['EmploymentNumber'] = ctxt.xpathEval('EmploymentInfo/Employee/EmployeeNumber')[0].getContent()
        except IndexError:
            #person does not have an EmploymentNumer. Generate error message and continue with NEXT person.
            logger.warn("person:%s does NOT have an EmploymentNumber. Person NOT processed" % person_dict)
            continue

        try:
            person_dict['Ssn'] = ctxt.xpathEval('SocialSecurityNumber')[0].getContent()
        except IndexError:
            # person does not have ssn.
            person_dict['Ssn']=''
            
        try:
            person_dict['Gender'] = ctxt.xpathEval('Gender')[0].getContent()
        except IndexError:
            # person does not have Gender set. This is not a problem.
            # A check of the persons SSN later in the code will reveal person gender
            person_dict['Gender'] = ''
            
        try:
            person_dict['Birthdate'] = ctxt.xpathEval('BirthDate')[0].getContent()
        except IndexError:
            # person does not have Birthday set. This is not a problem. A check of
            #the persons SSN later in the code will reveal person birthdate
            person_dict['Birthdate'] = ''
            
        try:
            person_dict['Firstname'] = ctxt.xpathEval('FirstName')[0].getContent()
            
        except IndexError:
            # This is not allowed. a Person MUST have a first name.
            # generate error message and continue with next person
            logger.warn("employee number %s is missing firstname in sito XML. person NOT processed" % (person_dict['EmploymentNumber']))
            continue

        try:
            person_dict['Middlename'] = ctxt.xpathEval('MiddleName')[0].getContent()
            logger.debug("collected middlename:%s" % person_dict['Middlename'])
        except IndexError:
            #this person has no middle name. do nothing
            pass

        try:
            person_dict['Lastname'] = ctxt.xpathEval('LastName')[0].getContent()
        except IndexError:
            # person does not have a lastname. 
            # Generate warning message and continue with NEXT person
            logger.warn("Employee:%s is missing LASTNAME in sito xml. person NOT processed" % person_dict['EmploymentNumber'])
            continue

        try:
            person_dict['Countrycode'] = ctxt.xpathEval('CountryCode')[0].getContent()
        except IndexError:
            # person is missing country code. Generate warning message and continue
            logger.warn("Employee:%s is missing country code in sito xml" % person_dict['EmploymentNumber'])
            person_dict['Countrycode'] = ''
            
        try:
            person_dict['Postalarea'] = ctxt.xpathEval('Addresses/Address/PostalArea')[0].getContent()
        except IndexError:
            # person is missing postalarea code. Generate warning message and continue
            logger.warning("Employee:%s is missing postalarea code in sito xml" % person_dict['EmploymentNumber'])
            person_dict['Postalarea'] = ''

        try:
            person_dict['Streetname'] = ctxt.xpathEval('Addresses/Address/StreetName1')[0].getContent()
        except IndexError:
            # person is missing streetname. generat warning message and continue
            logger.warning("Employee:%s is missing streetname in sito xml" % person_dict['EmploymentNumber'])
            person_dict['Streetname'] = ''

        try:
            person_dict['Zipcode'] = ctxt.xpathEval('Addresses/Address/ZipCode')[0].getContent()
        except IndexError:
            # person does not have a zipcode. generate warning message and continue
            logger.warning("employee number:%s does not have zipcode in sito xml" % person_dict['EmploymentNumber'])
            person_dict['Zipcode'] = ''
            
        
        try:
            person_dict['PositionCode'] = ctxt.xpathEval('EmploymentInfo/Employee/Employment/Employment/Position/SsbCode')[0].getContent()
        except IndexError:
            # person does not have a PositionCode in sito xml. generate warning message and continue
            logger.warning("Employee:%s does not have a PositionCode in sito xml" % person_dict['EmploymentNumber'])
            person_dict['PositionCode'] = ''

        try:
            person_dict['PositionName'] = ctxt.xpathEval('EmploymentInfo/Employee/Employment/Employment/Position/SsbName')[0].getContent()
        except IndexError:
            # person doest not have a PositionName in sito xml. Generate warning message and continue
            logger.warning("Employee: %s does not have a positionname in sito xml." % person_dict['EmploymentNumber'])
            person_dict['PositionName'] = ''

        afflist=list()
#        try:
##            person_dict['Affiliation'] = ctxt.xpathEval('EmploymentInfo/Employee/EmployedIn/Value')[0].getContent()
#            afflist.append( ctxt.xpathEval('EmploymentInfo/Employee/EmployedIn/Value')[0].getContent())
#        except IndexError:
#            # person does not an affiliation in sito xml. generate error message and continue with NEXT person
#            logger.warn("person:%s does not have an affiliation. Person NOT processed" % (person_dict['EmploymentNumber']))
#            continue
        try:
            person_dict['isDeactivated'] = ctxt.xpathEval('IsDeactivated')[0].getContent()
        except IndexError:
            # No IsDeactivated tag on person object. Return error message and continue
            logger.warn("Person:%s does not have IsDeactivated tag. Person NOT processed" % (person_dict['EmploymentNumber']))
            continue
        try:
            person_dict['Employment_description'] = ctxt.xpathEval('EmploymentInfo/Employee/Employment/Employment/Category/Name')[0].getContent()
        except IndexError:
            # No category name variable. does person have any affiliations at all?
            person_dict['Employment_description'] =''
            logger.warning("Employee:%s does not have any employment description name" % (person_dict['EmploymentNumber']))
        #try:
        #    person_dict['PositionPercent'] = ctxt.xpathEval('EmploymentInfo/Employee/Employment/Employment/EmploymentDistributionList/EmploymentDistribution/PositionPercent')[0].getContent()            
        #except IndexError:
        #    # person does not have a position percentage. does person have any affiliation at all?
        #    person_dict['PositionPercent'] = "0.0"
        #    logger.warning("Employee:%s does not have a position percentage" % (person_dict['EmploymentNumber']))
        try:
            person_dict['Email'] = ctxt.xpathEval('EMailAddresses/EMailAddress/Address')[0].getContent()
        except IndexError:
            # Person does not have email address
            logger.warning("EMployee:%s does not have a registered email address" %(person_dict['EmploymentNumber']))

        logger.debug("---- SSN ----:%s" % (person_dict['Ssn']))
        #print "today:%s" % TODAY
        # need to get all affiliations for this person
        for aff in person.xpathEval('EmploymentInfo/Employee/Employment/Employment'):
            unit = aff.xpathEval('EmploymentDistributionList/EmploymentDistribution/Unit/Value')[0].getContent() 
            #pp_from_xml = aff.xpathEval('EmploymentDistributionList/EmploymentDistribution/PositionPercent')[0].getContent()
            #logger.debug("now processing employment towards unit:%s") % unit
            #logger.debug("unit:%s" % unit)
            #if(float(pp_from_xml) >= (float(cereconf.SITO_AFFILIATION_PERCENTAGE))):
            # position percentage is more (or equal) than what is defined in cereconf.SITO_AFFILIATION_PERCENTAGE.
            # Check if this affiliation is valid:
            # if from_date < TODAY and to_date > TODAY:
            #    aff is valid
            # else:
            # aff is NOT valid
            #
            #person_dict['PositionPercent'] = pp_from_xml
            from_date = aff.xpathEval('FromDate')[0].getContent()
            to_date = aff.xpathEval('ToDate')[0].getContent()

            # convert dates so they are easier to compare
            TODAY_conv = "%s%s%s" % (TODAY[0:4],TODAY[5:7],TODAY[8:10])
            try:
                from_date_conv = "%s%s%s" %(from_date[0:4],from_date[5:7],from_date[8:10])
            except:
                logger.debug("\t has no from date")

            try:
                to_date_conv = "%s%s%s" %(to_date[0:4],to_date[5:7],to_date[8:10])
            except:
                logger.debug("\t has no To date")

            try:
                title  = aff.xpathEval('Position/Name')[0].getContent()
                #logger.info("3. title is calculated to:%s" % title)
            except:
                logger.info("Unable to get title for unit:%s" % unit)
            #logger.debug("\t has %s percentage on:%s" % (pp_from_xml,unit))                    
            if to_date !='':
                if from_date_conv <= TODAY_conv < to_date_conv:
                    logger.debug("\t Today %s is in range from:%s  to %s" %(TODAY_conv,from_date_conv, to_date_conv))
                    #logger.debug("\t TODAY_CONV:%s, FROM_DATE_CONV:%s, TO_DATE_CONV:%s" % (TODAY_conv,from_date_conv,to_date_conv))
                    logger.debug("\t appending: %s to aff_list" % (unit))
                    if unit not in afflist:
                        afflist.append(unit)
                        try:
                            person_dict['title'] =  title
                            logger.info("setting title to :%s" % person_dict['title'])
                        except:
                             logger.info("Unable to get title for position:%s" % unit)
                    else:
                        logger.debug("\t %s is already in this list" % (unit))
                else:
                    logger.debug("\t Today:%s is NOT in range from:%s to:%s" % (TODAY_conv,from_date_conv,to_date_conv))
                    logger.debug("\t NOT appending this affiliation. it is out of date.")
            if to_date == '':
                if from_date_conv <= TODAY_conv:
                    logger.debug("\t Today:%s is in range from:%s to: infinite" % (TODAY_conv,from_date_conv))
                    logger.debug("\t appending: %s to aff_list" % (unit))
                    if unit not in afflist:
                        logger.debug("I am actually appending ")
                        afflist.append(unit)
                        try:
                            person_dict['title'] =  title
                            logger.info("setting title to :%s" % person_dict['title'])
                        except:
                             logger.info("Unable to get title for position:%s" % unit)
                    else:
                        logger.debug("\t %s is already in this list" % (unit))
                        #afflist.append(unit)
                else:
                    #logger.debug("\t Today is NOT in range from:%s to: infinite" % (TODAY_conv,from_date_conv))
                    logger.debug("\t NOT appending this affiliation. it is out of date.")
            #print "afflist length=:%i" % len(afflist)
            if len(afflist) > 0:
                person_dict['Affiliation'] =",".join(afflist)
            #else:
            #    logger.warning("\t Employee:%s does not have a position percentage over 20percent on unit:%s" % (person_dict['EmploymentNumber'],unit))

        #
        # if a person has no active affiliations. continue with next person
        #
        try:
            person_dict['Affiliation']
        except KeyError:
            logger.debug("ssn:%s has no active affiliations" % (person_dict['Ssn']))
            continue
               
        # get all phone numbers
        person_dict['Phone']=''
        try:
            for phone in person.xpathEval('Phones/Phone'):
                if ((phone.xpathEval('Type')[0].getContent()) == ('CellPhone')):
                    person_dict['Phone'] += ",Cellphone:%s" % (phone.xpathEval('Number')[0].getContent())
                elif((phone.xpathEval('Type')[0].getContent()) == ('Home')):
                    person_dict['Phone'] += ",Home:%s" % (phone.xpathEval('Number')[0].getContent())
                elif((phone.xpathEval('Type')[0].getContent()) == ('DirectNumber')):
                    person_dict['Phone'] += ",Work:%s" % (phone.xpathEval('Number')[0].getContent())

        except IndexError:
            # person does not have a registered phone number. Do nothing.
            pass
        if person_dict['isDeactivated'] == 'false':
            person_list.append(person_dict)
    return person_list

        

#
# imports OU data from SITO
#
def generate_OU_list(datafile):

    if (os.path.isfile(datafile) == False):
            logger.error("file:%s doest not exist. Exiting" % datafile)
            sys.exit(1)

    ou_list = []

    #def read_utf8_xml(filename):
    #    data = open(filename).read()

        # Remove BOM (byte order marker)
        # ['\xef\xbb\xbf<?xml v']
        #data = data[data.index('<?xml'):]
        
        #data = data.decode('utf-8')
        #data = data.encode('iso-8859-1')
        #xml = libxml2.parseDoc(data)
        #return datafile.xpathNewContext()


    datafile = libxml2.parseFile(datafile) 
    ctxt = datafile.xpathNewContext()
    #ctxt = read_utf8_xml(datafile)
    
    i = 0
    for unit in ctxt.xpathEval("//Units/Unit"):
        ou_dir = {}
        ctxt.setContextNode(unit)
        #ou_dir['DepartmentCode'] = ctxt.xpathEval('./DepartmentCode')[0].getContent()
        ou_dir['unit_id'] = ctxt.xpathEval('./InternalInfo/Guid')[0].getContent()
        ou_dir['Name'] = ctxt.xpathEval('./Name')[0].getContent()
        ou_dir['ID'] = ctxt.xpathEval('./InternalInfo/Guid')[0].getContent()
        ou_dir['IsDeactivated'] = ctxt.xpathEval('./IsDeactivated')[0].getContent()
        try:
            ou_dir['ParentID'] = ctxt.xpathEval('./ParentUnitIdentifier/Value')[0].getContent()

        except IndexError:
            # not all ou's have a parent ou. continue generating
            # the list even if this parameter is missing.
            pass
        if ou_dir['IsDeactivated'] == 'false':
            ou_list.append(dict(ou_dir))

    return ou_list


#
# Stupid libxml2 insists on returning utf-8 encoded text.
# This function converts utf-8 to is-8859-1 so the text
# can propperly be stored in the database
#
def encode_decode_text(list,type):
    if type == 'OU':
        for ou in list:
            new_name = unicode(ou['Name'],'utf-8')
            ou['Name'] = new_name
    elif type == 'Person':
        for person in list:
            new_firstname = unicode(person['Firstname'],'utf-8')
            try:
                person['Middlename']
                new_middlename = unicode(person['Middlename'],'utf-8')
                person['Middlename'] = new_middlename
            except KeyError:
                # person has no middlename, do nothing
                pass
            
            new_lastname = unicode(person['Lastname'],'utf-8')
            new_positionname = unicode(person['PositionName'],'utf-8')
            new_title = unicode(person['title'],'utf-8')
            person['Firstname'] = new_firstname
            person['Lastname'] = new_lastname
            person['PositionName'] = new_positionname
            person['title'] = new_title
    return list

# KEB
# ou.populate() no longer sets name, acronym, short_name, display_name or sort_name
# this must handled with add_name_with_language()
def populate_the_rest(name, acronym, short_name, display_name, sort_name):
    
    name_language = const.language_nb
    logger
    ou.add_name_with_language(const.ou_name, name_language, name)
    ou.add_name_with_language(const.ou_name_acronym, name_language, acronym)
    ou.add_name_with_language(const.ou_name_short, name_language, short_name)
    ou.add_name_with_language(const.ou_name_display, name_language, display_name)
    # TODO: don't know what to do with sort_name, ignoring it for now.
    
def import_OU(ou_list,dryrun):

    # get sito ou's from BAS
    expire_list = None
    db_external_id = None
    parent_list = []
    perspective = getattr(const,"perspective_sito")
    all = ou.list_all_with_perspective(perspective) # also expired ou's

    try:
        expire_list = list(all)
    except TypeError:
        logger.warning("no ou's in bas with perspective perspective_sito")
        return -1
    #
    # insert or update SITO ou's in BAS
    #
    for sito_ou in ou_list:
        if(sito_ou['IsDeactivated'] == 'false'):
            logger.debug("--- Proccessing ou from ou file ---")
            # clear ou structure
            ou.clear()
            new_ou = False
            #
            # find ou in database if it already exists
            #
            try:
                #print "id_type=%s, external_id:%s, source_system:%s, entity_type:%s" %(const.externalid_sito_ou, sito_ou['unit_id'], const.system_sito, const.externalid_sito_ou)
                ou.find_by_external_id(id_type=const.externalid_sito_ou,external_id=sito_ou['unit_id'],source_system=const.system_sito,entity_type=const.externalid_sito_ou)
            except Errors.NotFoundError:
                # New ou.
                logger.info("new OU [%s, %s, %s] " % (sito_ou['Name'],sito_ou['unit_id'],sito_ou['IsDeactivated']))
                if(len(sito_ou['Name']) < 30):
                    # TODO: is there any point in this if-test, the same thing is done both places...
                    #print type(ou)
                    #ou.populate(name=sito_ou['Name'],acronym=None,short_name=sito_ou['Name'],display_name=sito_ou['Name'],sort_name=1,parent=None)
                    #ou.populate(sito_ou['Name'],None,sito_ou['Name'],sito_ou['Name'],1,None)
                    ou.populate()
                    ou.write_db()
                    populate_the_rest(sito_ou['Name'],sito_ou['Name'],sito_ou['Name'],sito_ou['Name'],1) #KEB
                else:
                    #ou.populate_withouth_sko()
                    ou.populate()
                    ou.write_db()
                    populate_the_rest(sito_ou['Name'],sito_ou['Name'],sito_ou['Name'],sito_ou['Name'],1) #KEB
                ou.write_db()
                ou.affect_external_id(const.system_sito,const.externalid_sito_ou)
                ou.populate_external_id(source_system=const.system_sito,id_type=const.externalid_sito_ou,external_id=sito_ou['unit_id'])
                ou.write_db()
                new_ou = True
            except EntityExpiredError,m:
                # ou is marked as active in import file, but inactive in database.
                # remove expire date from database
                # HACK: in order to get the ou_id of the expired ou we turn to some ugly string operations.
                # This because we want to remove the expire date on the ou being processed.
                tmp_str =  m.__str__()
                tmps = tmp_str.find(" ")
                tmps2 = tmp_str.rfind(" ")
                entity_id = tmp_str[tmps:tmps2]
                logger.warning("ReActivating OU, Removing expire date for ou_id:%s" % entity_id)
                
                e = EntityExpire(db)
                e.find(entity_id,expired_before="1970-01-01") # linux epoch date
                e._delete_expire_date()
                e.write_db()
                if(dryrun == False):
                    e.commit()
                e.clear()
                ou.clear()
                ou.find_by_external_id(id_type=const.externalid_sito_ou,external_id=sito_ou['unit_id'],source_system=const.system_sito,entity_type=const.externalid_sito_ou)
            else:
                # Found old ou. Overwrite old data.
                #logger.info("updating existing ou id:%s" % ou.entity_id)
                pass
                
            #
            # populate OU structure. If it was "found" above, the old information
            #  will be overwritten
            #
            if(new_ou == False):

                logger.info("DepartmentID:%s already has entity_id:%s." % (sito_ou['unit_id'],ou.entity_id))
                if(len(sito_ou['Name']) < 30):                    
                    # TODO: is there any point in this if-test, the same thing is done both places...
                    #ou.populate(sito_ou['Name'],acronym=None,short_name=sito_ou['Name'],display_name=sito_ou['Name'],sort_name=1,parent=None)
                    ou.populate()
                    populate_the_rest(sito_ou['Name'],sito_ou['Name'],sito_ou['Name'],sito_ou['Name'],1) # KEB
                else:
                    #ou.populate(name=sito_ou['Name'],acronym=None,short_name=None,display_name=sito_ou['Name'],sort_name=1,parent=None)
                    ou.populate()
                    populate_the_rest(sito_ou['Name'],sito_ou['Name'],sito_ou['Name'],sito_ou['Name'],1) # KEB
                ou.write_db()

            
            #
            # Create ou structure
            #
            found_parent = False
            for i in ou_list:
                ParentID = {}
                try:
                    if(sito_ou['ParentID'] == i['ID']):
                        ParentID = {'child': sito_ou['unit_id'], 'parent' : i['unit_id']}
                        parent_list.append(ParentID)
                        found_parent = True
                        break
                except:
                    pass
                
            if(found_parent == False):
                # ou has no parent, set parentID to 0 (root node)
                ParentID = {'child' : sito_ou['unit_id'], 'parent' : '0'}
                parent_list.append(ParentID)
        
            #    
            # Remove active OU's from ou expire list
            #
            if(sito_ou['IsDeactivated']== 'false'):
                #remove ou from list of inactive ou's
                if(len(expire_list)>0):
                    for unit in expire_list:
                        if(unit[0] == ou.entity_id):
                            expire_list.remove(unit)

    #
    # Need to commit to DB in order to set ou_structure
    # NOTE: we only commit if dryrun == False
    #
    if(dryrun == False):
        db.commit()
        logger.debug("Commit changes")
    #
    # Set parent for all ou's
    #

    for parent in parent_list:
        if(parent['parent'] == '0'):
            parent_entity_id = None
        else:
            ou.clear()
            try:
                ou.find_by_external_id(id_type=const.externalid_sito_ou,external_id=parent['parent'],source_system=const.system_sito,entity_type=const.entity_ou)
                parent_entity_id = ou.entity_id
                ou.clear()
            except Errors.NotFoundError:
                # unable to find parent ou. Lets hope this is the root node.
                continue
        try:
            ou.clear()
            ou.find_by_external_id(id_type=const.externalid_sito_ou,external_id=parent['child'],source_system=const.system_sito,entity_type=const.externalid_sito_ou)

        except Errors.NotFoundError:
            # unable to find child ou. This is fatal error.
            logger.error("UNABLE to find child ou with external id:%s" % parent['child'])
            
            

        #
        #
        # At this point parent entity_id is stored in parent_entity_id  (if it exists)
        # ou class should contain a child of mentioned parent_entity_id
        #
        #
        ou.set_parent(const.perspective_sito,parent_entity_id)
        ret_val = ou.write_db()

    #
    # Set expire date on ou's missing from import file, or has set IsDeactivated = true
    #    
    
    # get todays date
    t = time.localtime()
    try:
        for expired_ou in expire_list:
            ou.clear()
            try:
                ou.find(expired_ou[0])
            except EntityExpiredError:
                # This ou has already expired. Do nothing
                pass
            else:
                # This ou is expired in input file, but
                # active in DB. set expire_date in DB
                #ou.populate_expire_date("%02d%02d%02d" % (t[0], t[1], t[2]))
                ou.write_db()
    except TypeError:
        logger.warning("cannot set expire date from empty list")

        
def usage(exitcode=0,msg=None):
    if msg:
        print msg
    print __doc__
    sys.exit(exitcode)

def main():
    global cere_list
    personfile = '/cerebrum/var/dumps/sito/gjeldende_person'
    oufile = '/cerebrum/var/dumps/sito/gjeldende_unit'
    execute_ou = False
    execute_person = False
    dryrun = False
    logger=Factory.get_logger('console')
    person_list = []
    try:
        opts, args = getopt.getopt(sys.argv[1:],'p:o:dh',['person_file=','ou_file=','dryrun','help'])
    except getopt.GetoptError,m:
        usage(1,m)

    for opt, val in opts:
        if opt in('-p','--person_file'):
            execute_person = True
            input_personfile = val
        elif opt in ('-o','ou_file'):
            execute_ou = True
            input_oufile = val
        elif opt in ('-d','--dryrun'):
            dryrun = True
        elif opt in ('-h','--help'):
            usage()
        else:
            usage()
    
    if(execute_person == True):
        personfile = input_personfile
    if(execute_ou == True):
        oufile = input_oufile
        
    #
    # only execute ou processing if no parameters are given, or if only the ou parameter is given
    #
    #
    if (((execute_ou == True) and (execute_person == False)) or ((execute_ou == False) and (execute_person == False))):
        logger.info("\t ## Generating OU list ##")
        ou_list = generate_OU_list(oufile)
        logger.info("\t ## OU list finished ##")

        logger.info("\t ## decode/encode text in OU list ##")
        ou_list = encode_decode_text(ou_list,'OU')
        logger.info("\t ## decode/encode finished ##")

        logger.info("\t ## Import OU ##")
        ret = import_OU(ou_list,dryrun)
        logger.info("\t ## OU import finished ##")
        

    #
    # Only execute person processing if no parameters are given, or if only the person parameter is given.
    #
    if(((execute_ou == False) and (execute_person == True)) or ((execute_ou == False)and(execute_person == False))):

        logger.info("\t ## Generate list of all sito person affiliations ##")
        cere_list = load_all_affi_entry()
        logger.info("\t ## Done ## ")
       

        # create a list of all sito person affiliations                
        logger.info("\t ## Generate Person list ##")
        person_list = generate_person_list(personfile,person_list)
        logger.info("\t ## Person list finished")
        #pprint(person_list)
        logger.info("\t ## decode/encode person names##")
        person_list = encode_decode_text(person_list,'Person')
        logger.info("\t ## decode/encode finished##")


        logger.info("\t ## Import person ##")
        import_person(person_list)
        logger.info("\t ## Person import finished ##")


        # remove any person affiliations set as "not False" in cere_list
        logger.info("\t ## Removing expired person affiliations ##")
        clean_affi_s_list()
        logger.info("\t ## Old affiliations removed ##")


    #
    # Commit to DB if dryrun flag is set to False, otherwise rollback changes
    #
    if(dryrun == False):
        logger.info("\t ## commiting to DB ##")
        db.commit()
    elif(dryrun == True):
        db.rollback()
        logger.warning("\t ## Dryrun: NOT commiting to DB ##")

if __name__ == '__main__':
    main()

