#! /usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright 2004-2019 University of Oslo, Norway
#
# This file is part of Cerebrum.
#
# Cerebrum is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Cerebrum is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Cerebrum; if not, write to the Free Software Foundation,
# Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

# Global imports
"""
import_sito.py can import person and/or ou data into BAS.

The person and ou files are xml files generated by SITO HR systems.
"""
from __future__ import print_function, unicode_literals

import argparse
import datetime
import logging
import os
import string
import xml.etree.ElementTree

import mx.DateTime

import cereconf

import Cerebrum.logutils
import Cerebrum.logutils.options
from Cerebrum import Errors
from Cerebrum.Utils import Factory
from Cerebrum.modules.entity_expire.entity_expire import EntityExpire
from Cerebrum.modules.entity_expire.entity_expire import EntityExpiredError
from Cerebrum.modules.no import fodselsnr
from Cerebrum.utils.argutils import add_commit_args


# Global variables
progname = __file__.split(os.sep)[-1]
db = Factory.get('Database')()
db.cl_init(change_program=progname)
const = Factory.get('Constants')(db)
ou = Factory.get('OU')(db)
person = Factory.get('Person')(db)
new_person = Factory.get('Person')(db)
e = Factory.get('Entity')(db)

logger = logging.getLogger(__name__)


def parse_date(date_str):
    """
    Parse a date on the strfdate format "%Y-%m-%d".

    :rtype: datetime.date
    :return: Returns the date object, or ``None`` if an invalid date is given.
    """
    try:
        args = (int(date_str[0:4]),
                int(date_str[5:7]),
                int(date_str[8:10]))
        return datetime.date(*args)
    except Exception:
        logger.warning('Invalid date %r', date_str)
        return None


def date_in_range(date, from_date=None, to_date=None):
    """
    Checks if a given date is within a date range.

    If any of the thresholds (from_date, to_date) is ``None``, that threshold
    will not be checked. I.e. ``date_in_range(<some date>)`` will *always* be
    ``True``.

    :param date: The date or datetime to check
    :param from_date: lower threshold, inclusive, if this needs to be checked.
    :param to_date: upper threshold, if this needs to be checked

    :rtype: bool
    :return: True if date is within the given range.
    """
    if from_date is not None and date < from_date:
        logger.debug('date=%r before from_date=%r', date, from_date)
        return False
    if to_date is not None and date >= to_date:
        logger.debug('date=%r after to_date=%r', date, from_date)
        return False
    logger.debug('date=%r within from_date=%r to_date=%r',
                 date, from_date, to_date)
    return True


# XML-Type to csv type
phone_mapping = {
    'CellPhone': 'Cellphone',
    'Home': 'Home',
    'DirectNumber': 'Work',
}


def parse_person_phones(person):
    """
    Parse person phone numbers.

    :param person: A //Persons/Person element

    :rtype: generator
    :return: A generator that yield (phone_type, phone_number) pairs
    """
    for phone in person.findall('./Phones/Phone'):
        try:
            p_type = phone.find('./Type').text
            p_number = phone.find('./Number').text
        except AttributeError as e:
            logger.debug('Skipping phone=%r: %s', phone, e)

        if p_type in phone_mapping.keys():
            yield phone_mapping[p_type], p_number


def parse_person_employments(person):
    """
    Parse a single employment value.

    :param person: A //Persons/Person element

    :rtype: generator
    :return:
        A generator that yields (employment_title, employment_unit) pairs
    """
    today = datetime.date.today()

    for employment in person.findall('EmploymentInfo/Employee/'
                                     'Employment/Employment'):

        unit = employment.find('EmploymentDistributionList/'
                               'EmploymentDistribution/Unit/Value').text

        from_date = parse_date(employment.find('FromDate').text)
        to_date = parse_date(employment.find('ToDate').text)

        if not date_in_range(today, from_date, to_date):
            logger.debug('Skipping non-current employment at unit=%r', unit)
            continue

        try:
            title = employment.find('Position/Name').text
        except Exception:
            logger.info("Unable to get title for unit=%r", unit)
            title = None

        yield title, unit


def parse_person(person):

    employee_id = None

    def get_required(xpath):
        elem = person.find(xpath)
        if elem is None:
            raise ValueError(
                'Missing required element %r in person=%r, employee_id=%r' %
                (xpath, person, employee_id))
        else:
            return elem.text

    # Mandatory params
    employee_id = get_required('EmploymentInfo/Employee/EmployeeNumber')
    fname = get_required('FirstName')
    lname = get_required('LastName')
    deactivated = get_required('IsDeactivated') != 'false'

    def get(xpath, default=None):
        elem = person.find(xpath)
        if elem is None:
            logger.warning('Missing element %r for employee_id=%r',
                           xpath, employee_id)
            return default
        else:
            return elem.text or ''

    person_dict = {
        'EmploymentNumber': employee_id,
        'Ssn': get('SocialSecurityNumber', ''),
        'Gender': get('Gender', ''),
        'Birthdate': get('BirthDate', ''),
        'Firstname': fname,
        'Lastname': lname,
        'Countrycode': get('CountryCode', ''),
        'Postalarea': get('Addresses/Address/PostalArea', ''),
        'Streetname': get('Addresses/Address/StreetName1', ''),
        'Zipcode': get('Addresses/Address/ZipCode', ''),
        'PositionCode': get('EmploymentInfo/Employee/Employment/'
                            'Employment/Position/SsbCode', ''),
        'PositionName': get('EmploymentInfo/Employee/Employment/'
                            'Employment/Position/SsbName', ''),
        'isDeactivated': deactivated,
        'Employment_description': get('EmploymentInfo/Employee/Employment/'
                                      'Employment/Category/Name', ''),
    }

    mname = get('MiddleName')
    if mname is not None:
        person_dict['Middlename'] = mname

    email = get('EMailAddresses/EMailAddress/Address')
    if email is not None:
        person_dict['Email'] = email

    # Affiliation and title
    #
    afflist = list()
    for title, unit in parse_person_employments(person):
        if title and unit not in afflist:
            person_dict['title'] = title
        if unit not in afflist:
            afflist.append(unit)

    if len(afflist) > 0:
        logger.debug('Got %d affiliations for employee_id=%r',
                     len(afflist), employee_id)
        person_dict['Affiliation'] = ",".join(afflist)

    # Phone
    #
    phone_numbers = list(parse_person_phones(person))
    person_dict['Phone'] = ','.join('{}:{}'.format(k, v)
                                    for k, v in phone_numbers)
    logger.debug('Got %d phone numbers for employee_id=%r',
                 len(phone_numbers), employee_id)
    return person_dict


def generate_persons(filename):
    """
    Find and parse employee data from an xml file.
    """
    if not os.path.isfile(filename):
        raise OSError('No file %r' % (filename, ))

    tree = xml.etree.ElementTree.parse(filename)

    # TODO: Future versions: just do tree.findall('//Persons/Person')
    root = tree.getroot()
    for i, person in enumerate(root.findall(".//Persons/Person"), 1):
        try:
            person_dict = parse_person(person)
        except Exception:
            logger.error('Skipping person #%d (element=%r), invalid data',
                         i, person, exc_info=True)
            continue

        if person_dict['isDeactivated']:
            logger.info('Skipping person #%d (employee_id=%r), deactivated',
                        i, person_dict['EmploymentNumber'])
            continue

        if not person_dict.get('Affiliation'):
            logger.info('Skipping person #%d (employee_id=%r), '
                        'no affiliations',
                        i, person_dict['EmploymentNumber'])
            continue

        yield person_dict


def parse_unit(unit):
    """
    Parse an ElementTree 'Unit' element.

    :param unit: A 'Unit' element

    :return: A dict-representation of the unit.
    """
    ou_dict = {
        'unit_id': unit.find('InternalInfo/Guid').text,
        'Name': unit.find('Name').text,
        'ID': unit.find('InternalInfo/Guid').text,
        'IsDeactivated': unit.find('IsDeactivated').text != 'false',
    }

    parent_id = unit.find('ParentUnitIdentifier/Value')
    if parent_id is not None:
        ou_dict['ParentID'] = parent_id.text

    return ou_dict


def generate_ous(filename):
    """
    Find and parse org unit data from an xml file.
    """
    if not os.path.isfile(filename):
        raise OSError('No file %r' % (filename, ))

    tree = xml.etree.ElementTree.parse(filename)

    # TODO: Future versions: just to tree.findall('//Units/Unit')
    root = tree.getroot()

    for i, unit in enumerate(root.findall(".//Units/Unit"), 1):
        try:
            ou_dict = parse_unit(unit)
        except Exception:
            logger.error('Unable to parse unit #%d, unit=%r', i, unit)
            raise

        if ou_dict['IsDeactivated']:
            logger.info('Skipping unit #%d, disabled', i)
            continue

        yield ou_dict


def load_all_affi_entry():
    person = Factory.get('Person')(db)
    affi_list = {}
    for row in person.list_affiliations(source_system=const.system_sito):
        key_l = "%s:%s:%s" % (row['person_id'], row['ou_id'],
                              row['affiliation'])
        affi_list[key_l] = True
    return affi_list


def clean_affi_s_list(cere_list):
    for k, v in cere_list.items():
        if v:
            [ent_id, ou, affi] = [int(x) for x in k.split(':')]
            new_person.clear()
            new_person.entity_id = int(ent_id)
            affs = new_person.list_affiliations(
                ent_id,
                affiliation=affi,
                ou_id=ou,
                source_system=const.system_sito)
            for aff in affs:
                last_date = datetime.datetime.fromtimestamp(aff['last_date'])
                end_grace_period = (
                    last_date +
                    datetime.timedelta(
                        days=cereconf.GRACEPERIOD_EMPLOYEE_SITO))
                if datetime.datetime.today() > end_grace_period:
                    logger.warn(
                        "Deleting system_sito affiliation for "
                        "person_id=%s,ou=%s,affi=%s last_date=%s,grace=%s",
                        ent_id, ou, affi, last_date,
                        cereconf.GRACEPERIOD_EMPLOYEE_SITO)
                    new_person.delete_affiliation(ou, affi, const.system_sito)


#
# import SITO persons into BAS
#
def import_person(person_list, cere_list):
    """
    Persons (from person_list) being processed in this function will have the
    following variables

    - ssn = 11 digit | ''
    - gender = Male/Female | ''
    - Birthdate = YYYY-MM-DDT00:00:00
    - Firstname = somename
    - Lastname = somename
    - countrycode = NN | ''
    - postalarea = someaddress | ''
    - streetname = somestreet | ''
    - zipcode = somezipcode | ''
    - employmentnumber = somenumber
    - positioncode = somenumber | ''
    - positionname = somename | ''
    - affiliation = some_organization_id
    """
    for person in person_list:
        ssn_not_valid = False
        valid_birthdate = True
        person_processed = {}

        logger.info("--- Processing employee number:%s ---",
                    person['EmploymentNumber'])

        #
        # Get Person Birthdate
        #
        try:
            person_processed.update({
                'birth_year': int(person['Birthdate'][0:4]),
                'birth_month': int(person['Birthdate'][5:7]),
                'birth_day': int(person['Birthdate'][8:10]),
            })
        except ValueError:
            valid_birthdate = False
            logger.warning("Empty Birthdate string for employee number:%s.",
                           person['EmploymentNumber'])

        #
        # check if SSN is registered and valid
        #
        try:
            fodselsnr.personnr_ok(person['Ssn'])
            person_processed['ssn'] = person['Ssn']
        except fodselsnr.InvalidFnrError:
            logger.warning("Empty SSN for employee number:%s",
                           person['EmploymentNumber'])
            ssn_not_valid = True
            person_processed['ssn'] = ''

        #
        # set person gender (checking both SSN and gender from sito input file)
        #
        gender = const.gender_male
        if not ssn_not_valid:
            if fodselsnr.er_kvinne(person['Ssn']):
                gender = const.gender_female
        elif gender != person['Gender'][0] == 'F':
            # ssn is not valid. use Gender variable from sito import file
            # instead.
            gender = const.gender_female
        else:
            # person has neither ssn nor gender set in import file. impossible
            # to set gender.
            logger.warning("impossible to set gender for employee number:%s."
                           " using Unknown", person['EmploymentNumber'])
            gender = const.gender_unknown

        person_processed['gender'] = gender

        #
        # Validate Birthdate against SSN
        #
        if not ssn_not_valid and valid_birthdate:
            (year_check,
             month_check,
             day_check) = fodselsnr.fodt_dato(person['Ssn'])
            # person has ssn and birthdate. verify the data
            if year_check != person_processed['birth_year']:
                logger.warn("Year inconsistent between XML (%s) and FNR (%s) "
                            "for employee:%s", person_processed['birth_year'],
                            year_check, person['EmploymentNumber'])
                continue
            if month_check != person_processed['birth_month']:
                logger.warn("Month inconsistent between XML (%s) and FNR (%s) "
                            "for employee %s", person_processed['birth_month'],
                            month_check, person['EmploymentNumber'])
                continue
            if day_check != person_processed['birth_day']:
                logger.warn("Day inconsistent between XML (%s) and FNR (%s) "
                            "for person %s", person_processed['birth_day'],
                            day_check, person['EmploymentNumber'])
                continue
        elif not ssn_not_valid and not valid_birthdate:
            # person has ssn but not birthdate. set birthdate based on ssn.
            logger.warn("person:%s is missing birthdate. Setting it based "
                        "on SSN", person['Ssn'])
            if fodselsnr.personnr_ok(person['Ssn']):
                year, mon, day = fodselsnr.fodt_dato(person['Ssn'])
                person_processed.update({
                    'birth_year':  year,
                    'birth_month':  mon,
                    'birth_day':  day,
                })
            else:
                continue

        elif valid_birthdate and ssn_not_valid:
            # person have birthdate but NOT ssn. Nothing to do here
            pass

        elif not valid_birthdate and ssn_not_valid:
            # person does not have birthdate nor ssn. This person cannot be
            # built.  SSN or Birthdate required. Return error message and
            # continue with NEXT person
            logger.warn("Employee number: %s is missing SSN and Birthdate. "
                        "NOT imported", person['EmploymentNumber'])
            continue

        #################################################
        # collect various person data from person list  #
        #################################################

        person_processed.update({
            'ansattnr': person['EmploymentNumber'],
            'Firstname': person['Firstname'],
            'Lastname': person['Lastname'],
            'PositionName': person['PositionName'],
            'title': person['title'],
        })
        if 'Middlename' in person:
            person_processed['Middlename'] = person['Middlename']

        #
        # Get person object som DB if it exists
        #

        new_person.clear()
        try:
            new_person.find_by_external_id(const.externalid_sito_ansattnr,
                                           person_processed['ansattnr'])
        except Errors.NotFoundError:
            # could not find person in DB based on ansattnr.
            if not ssn_not_valid:
                # try to find person using ssn if ssn is valid
                try:
                    new_person.clear()
                    new_person.find_by_external_id(const.externalid_fodselsnr,
                                                   person_processed['ssn'])
                except Errors.NotFoundError:
                    # Could not find person in DB based on fnr
                    logger.info("-- Create new person object for ssn:%s --",
                                person_processed['ssn'])
                    pass

        if (person_processed['Firstname'].isspace() or
                person_processed['Lastname'].isspace()):
            # Firstname and/or lastname is made of whitespace ONLY.
            # generate error message and continue with NEXT person
            logger.error("missing first and/or lastname for person:%s. "
                         "Person NOT imported", person)
            continue

        #
        # Populate the person object
        #
        try:
            new_person.populate(
                mx.DateTime.Date(person_processed['birth_year'],
                                 person_processed['birth_month'],
                                 person_processed['birth_day']),
                gender)
        except Errors.CerebrumError as m:
            logger.error("Person: %s populate failed: %s",
                         person_processed['ssn'] or
                         person_processed['ansattnr'], m)
            # population of person object failes. Continue
            continue
        new_person.affect_names(const.system_sito, const.name_first,
                                const.name_last, const.name_work_title)
        new_person.affect_external_id(const.system_sito,
                                      const.externalid_fodselsnr,
                                      const.externalid_sito_ansattnr)
        try:
            person_processed['Middlename']
            concat_firstname = "%s %s" % (person_processed['Firstname'],
                                          person_processed['Middlename'])
            person_processed['Firstname'] = concat_firstname
            logger.debug("CONCAT FIRSTNAME:%s", person_processed['Firstname'])
        except KeyError:
            # person has no middlename. use original firstname
            pass
        new_person.populate_name(const.name_first,
                                 person_processed['Firstname'])
        new_person.populate_name(const.name_last, person_processed['Lastname'])

        logger.warning("person_processed title is:%s",
                       person_processed['title'])
        if person_processed['title'] != '':
            new_person.populate_name(const.name_work_title,
                                     person_processed['title'])
        if person_processed['ssn'] != '':
            new_person.populate_external_id(const.system_sito,
                                            const.externalid_fodselsnr,
                                            person_processed['ssn'])
            logger.info("setting external_id to:%s", person_processed['ssn'])
        new_person.populate_external_id(const.system_sito,
                                        const.externalid_sito_ansattnr,
                                        person_processed['ansattnr'])

        # In case this is a new person, we will need to write to DB before we
        # can continue.
        new_person.write_db()

        affiliation = determine_affiliations(person)
        new_person.populate_affiliation(const.system_sito)
        contact = determine_contact(person)
        new_person.populate_contact_info(const.system_sito)

        # set person affiliation
        for k, v in affiliation.items():
            ou_id, aff, aff_stat = v
            logger.info("Has affiliation %s towards ou:%s", aff_stat, ou_id)
            new_person.populate_affiliation(const.system_sito, ou_id,
                                            int(aff), int(aff_stat))

            # set this persons affiliation entry to False
            # this ensures that this persons affiliations will not be removed
            # when the clean_affiliation function is called after import person
            if k in cere_list:
                cere_list[k] = False

        # get person work, cellular and home phone numbers
        c_prefs = {}
        for con, number in contact.items():
            if con == 'Cellphone':
                c_type = int(const.contact_mobile_phone)
            if con == 'Home':
                c_type = int(const.contact_phone_private)
            if con == 'Work':
                c_type = int(const.contact_phone)
            pref = c_prefs.get(c_type, 0)
            new_person.populate_contact_info(const.system_sito, c_type, number,
                                             pref)
            logger.debug("system:%s, c_type:%s, number:%s, pref:%s",
                         const.system_sito, c_type, number, pref)
            pref = c_prefs[c_type] = pref = 1

        op2 = new_person.write_db()
        logger.info("WriteDB after affs: %s" % (op2,))


def determine_contact(person):
    phone_info = {}
    phone = string.split(person['Phone'], ',')
    for single_phone in phone:
        single_phone = single_phone.strip()
        if(len(single_phone) > 0):
            # append each phone type to returning object
            type, number = single_phone.split(":")
            phone_info[type] = number
    return phone_info


#
# Get ou_id based on external_id
#
def get_ou(a, person):

    external_id = a.split(",")

    for single_id in external_id:
        ou.clear()
        try:
            ou.find_by_external_id(id_type=const.externalid_sito_ou,
                                   external_id=single_id,
                                   source_system=const.system_sito,
                                   entity_type=const.entity_ou)
        except EntityExpiredError:
            # person registered to expired OU. return error message.
            logger.error("person:%s is registered to expired OU "
                         "with external_id:%s", person['Ssn'], single_id)
            return -1
        except Errors.NotFoundError:
            logger.error("WARNING - person:%s %s is registered to a "
                         "nonexisting OU with external id:%s",
                         person['Firstname'], person['Lastname'], single_id)
            return -1

        if single_id == cereconf.DEFAULT_SITO_ROOT_HASH:
            logger.info("person:%s has affiliation to SITO root node",
                        person['Ssn'])
        return ou.entity_id


#
# will return a list of:
# ou_id              - organizational ID
# affiliation        - Ansatt
# affiliation type   - (tekadn,adm)
#
# For all person affiliations
#
def determine_affiliations(person):
    ret = {}
    # percentage = []
    aff = const.affiliation_ansatt_sito
    aff_stat = ''
    t = person['Affiliation'].split(",")
    for a in t:
        person['Employment_description']
        aff_stat = const.affiliation_status_ansatt_sito
        ou = get_ou(a, person)
        if ou == -1:
            # unable to find OU.
            logger.error("Got -1 from get_ou %s" % a)
            continue
        else:
            # valid ou id found. continue processing
            k = "%s:%s:%s" % (new_person.entity_id, ou, int(aff))
            if k not in ret:
                ret[k] = ou, const.affiliation_ansatt_sito, aff_stat
    return ret


# KEB
# ou.populate() no longer sets name, acronym, short_name, display_name or
# sort_name this must handled with add_name_with_language()

def populate_the_rest(name, acronym, short_name, display_name, sort_name):
    name_language = const.language_nb
    ou.add_name_with_language(const.ou_name, name_language, name)
    ou.add_name_with_language(const.ou_name_acronym, name_language, acronym)
    ou.add_name_with_language(const.ou_name_short, name_language, short_name)
    ou.add_name_with_language(const.ou_name_display, name_language,
                              display_name)
    # TODO: don't know what to do with sort_name, ignoring it for now.


def import_ou(ou_list, dryrun):
    # get sito ou's from BAS
    expire_list = None
    parent_list = []
    perspective = getattr(const, "perspective_sito")
    all = ou.list_all_with_perspective(perspective)  # also expired ou's

    try:
        expire_list = list(all)
    except TypeError:
        logger.warning("no ou's in bas with perspective perspective_sito")
        return -1
    #
    # insert or update SITO ou's in BAS
    #
    for sito_ou in ou_list:
        if(sito_ou['IsDeactivated'] == 'false'):
            logger.debug("--- Proccessing ou from ou file ---")
            # clear ou structure
            ou.clear()
            new_ou = False
            #
            # find ou in database if it already exists
            #
            try:
                ou.find_by_external_id(id_type=const.externalid_sito_ou,
                                       external_id=sito_ou['unit_id'],
                                       source_system=const.system_sito,
                                       entity_type=const.externalid_sito_ou)
            except Errors.NotFoundError:
                # New ou.
                logger.info("new OU [%s, %s, %s] ", sito_ou['Name'],
                            sito_ou['unit_id'], sito_ou['IsDeactivated'])
                ou.populate()
                ou.write_db()
                populate_the_rest(sito_ou['Name'], sito_ou['Name'],
                                  sito_ou['Name'], sito_ou['Name'], 1)
                ou.write_db()
                ou.affect_external_id(const.system_sito,
                                      const.externalid_sito_ou)
                ou.populate_external_id(source_system=const.system_sito,
                                        id_type=const.externalid_sito_ou,
                                        external_id=sito_ou['unit_id'])
                ou.write_db()
                new_ou = True

            except EntityExpiredError as m:
                # ou is marked as active in import file, but inactive in
                # database.
                # remove expire date from database
                # HACK: in order to get the ou_id of the expired ou we turn to
                # some ugly string operations.  This because we want to remove
                # the expire date on the ou being processed.
                tmp_str = str(m)
                tmps = tmp_str.find(" ")
                tmps2 = tmp_str.rfind(" ")
                entity_id = tmp_str[tmps:tmps2]
                logger.warning("ReActivating OU, Removing expire date "
                               "for ou_id:%s", entity_id)

                e = EntityExpire(db)
                e.find(entity_id, expired_before="1970-01-01")  # linux epoch
                e._delete_expire_date()
                e.write_db()
                if not dryrun:
                    e.commit()
                e.clear()
                ou.clear()
                ou.find_by_external_id(id_type=const.externalid_sito_ou,
                                       external_id=sito_ou['unit_id'],
                                       source_system=const.system_sito,
                                       entity_type=const.externalid_sito_ou)
            else:
                # Found old ou. Overwrite old data.
                pass

            #
            # populate OU structure. If it was "found" above, the old
            # information will be overwritten
            #
            if not new_ou:
                logger.info("DepartmentID:%s already has entity_id:%s.",
                            sito_ou['unit_id'], ou.entity_id)
                ou.populate()
                populate_the_rest(sito_ou['Name'], sito_ou['Name'],
                                  sito_ou['Name'], sito_ou['Name'], 1)
                ou.write_db()

            #
            # Create ou structure
            #
            found_parent = False
            for i in ou_list:
                parentid = {}
                try:
                    if sito_ou['ParentID'] == i['ID']:
                        parentid = {
                            'child': sito_ou['unit_id'],
                            'parent': i['unit_id'],
                        }
                        parent_list.append(parentid)
                        found_parent = True
                        break
                except:
                    pass

            if not found_parent:
                # ou has no parent, set parentID to 0 (root node)
                parentid = {
                    'child': sito_ou['unit_id'],
                    'parent': '0',
                }
                parent_list.append(parentid)

            #
            # Remove active OU's from ou expire list
            #
            if sito_ou['IsDeactivated'] == 'false':
                # remove ou from list of inactive ou's
                if len(expire_list) > 0:
                    for unit in expire_list:
                        if unit[0] == ou.entity_id:
                            expire_list.remove(unit)

    #
    # Need to commit to DB in order to set ou_structure
    # NOTE: we only commit if dryrun == False
    #
    if not dryrun:
        db.commit()
        logger.debug("Commit changes")

    #
    # Set parent for all ou's
    #
    for parent in parent_list:
        if(parent['parent'] == '0'):
            parent_entity_id = None
        else:
            ou.clear()
            try:
                ou.find_by_external_id(id_type=const.externalid_sito_ou,
                                       external_id=parent['parent'],
                                       source_system=const.system_sito,
                                       entity_type=const.entity_ou)
                parent_entity_id = ou.entity_id
                ou.clear()
            except Errors.NotFoundError:
                # unable to find parent ou. Lets hope this is the root node.
                continue
        try:
            ou.clear()
            ou.find_by_external_id(id_type=const.externalid_sito_ou,
                                   external_id=parent['child'],
                                   source_system=const.system_sito,
                                   entity_type=const.externalid_sito_ou)

        except Errors.NotFoundError:
            # unable to find child ou. This is fatal error.
            logger.error("UNABLE to find child ou with external id:%s",
                         parent['child'])

        #
        # At this point parent entity_id is stored in parent_entity_id  (if it
        # exists) ou class should contain a child of mentioned parent_entity_id
        #
        ou.set_parent(const.perspective_sito, parent_entity_id)
        ou.write_db()

    #
    # Set expire date on ou's missing from import file, or has set
    # IsDeactivated = true
    #

    try:
        for expired_ou in expire_list:
            ou.clear()
            try:
                ou.find(expired_ou[0])
            except EntityExpiredError:
                # This ou has already expired. Do nothing
                pass
            else:
                # This ou is expired in input file, but
                # active in DB. set expire_date in DB
                ou.write_db()
    except TypeError:
        logger.warning("cannot set expire date from empty list")


default_log_preset = getattr(cereconf, 'DEFAULT_LOGGER_TARGET', 'console')


def main(inargs=None):
    parser = argparse.ArgumentParser(
        description="Import SITO XML files into the Cerebrum database")

    parser.add_argument(
        '-p', '--person-file',
    )
    parser.add_argument(
        '-o', '--ou-file',
    )
    add_commit_args(parser)
    Cerebrum.logutils.options.install_subparser(parser)

    args = parser.parse_args(inargs)
    Cerebrum.logutils.autoconf(default_log_preset, args)

    logger.info('Start of %s', parser.prog)
    logger.debug('args: %r', args)

    dryrun = not args.commit

    if args.ou_file:
        logger.info('Fetching OUs from %r', args.ou_file)
        ou_list = list(generate_ous(args.ou_file))
        logger.info('Importing %d OUs', len(ou_list))
        import_ou(ou_list, dryrun)
        logger.info('OU import done')

    if args.person_file:
        logger.info('Loading existing affiliations')
        cere_list = load_all_affi_entry()
        logger.info('Fetching persons from %r', args.person_file)
        person_list = list(generate_persons(args.person_file))
        logger.info('Importing %d persons', len(person_list))
        import_person(person_list, cere_list)
        logger.info('Cleaning old affiliations')
        clean_affi_s_list(cere_list)
        logger.info('Person import done')

    if args.commit:
        logger.info('Commiting changes')
        db.commit()
    else:
        db.rollback()
        logger.info('Rolling back changes')
    logger.info('Done %s', parser.prog)


if __name__ == '__main__':
    main()
