#! /usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright 2004-2019 University of Oslo, Norway
#
# This file is part of Cerebrum.
#
# Cerebrum is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# Cerebrum is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Cerebrum; if not, write to the Free Software Foundation,
# Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

# Global imports
from __future__ import print_function, unicode_literals

import datetime
import getopt
import os
import string
import sys

import libxml2
import mx.DateTime

# Cerebrum imports
import cereconf

from Cerebrum import Errors
from Cerebrum.Utils import Factory
from Cerebrum.modules.entity_expire.entity_expire import EntityExpire
from Cerebrum.modules.entity_expire.entity_expire import EntityExpiredError
from Cerebrum.modules.no import fodselsnr


# Global variables
progname = __file__.split(os.sep)[-1]
db = Factory.get('Database')()
db.cl_init(change_program=progname)
const = Factory.get('Constants')(db)
ou = Factory.get('OU')(db)
person = Factory.get('Person')(db)
new_person = Factory.get('Person')(db)
e = Factory.get('Entity')(db)

# init the logger.
logger = Factory.get_logger(cereconf.DEFAULT_LOGGER_TARGET)

# initiate global datetime for today
TODAY = mx.DateTime.today().strftime("%Y-%m-%d")

# Doc string
__doc__ = """
import_sito.py can import person and/or ou data into BAS.
the person and ou files are xml files generated by SITO HR systems

usage:: %s [-p <filename> | -o <filename>] [-d]

options:
   [-p|--person_file <filename>] - person file
   [-o|--ou_file] <filename>     - ou file
   [-d|--dryrun]                 - do not write to database
   [-h|--help]                   - this text
""" % (progname)


def load_all_affi_entry():
    affi_list = {}
    for row in new_person.list_affiliations(source_system=const.system_sito):
        key_l = "%s:%s:%s" % (row['person_id'], row['ou_id'],
                              row['affiliation'])
        affi_list[key_l] = True
    return(affi_list)


def clean_affi_s_list():
    for k, v in cere_list.items():
        if v:
            [ent_id, ou, affi] = [int(x) for x in k.split(':')]
            new_person.clear()
            new_person.entity_id = int(ent_id)
            affs = new_person.list_affiliations(
                ent_id,
                affiliation=affi,
                ou_id=ou,
                source_system=const.system_sito)
            for aff in affs:
                last_date = datetime.datetime.fromtimestamp(aff['last_date'])
                end_grace_period = (
                    last_date +
                    datetime.timedelta(
                        days=cereconf.GRACEPERIOD_EMPLOYEE_SITO))
                if datetime.datetime.today() > end_grace_period:
                    logger.warn(
                        "Deleting system_sito affiliation for "
                        "person_id=%s,ou=%s,affi=%s last_date=%s,grace=%s",
                        ent_id, ou, affi, last_date,
                        cereconf.GRACEPERIOD_EMPLOYEE_SITO)
                    new_person.delete_affiliation(ou, affi, const.system_sito)


#
# import SITO persons into BAS
#
def import_person(person_list):
    """
    Persons (from person_list) being processed in this function will have the
    following variables

    - ssn = 11 digit | ''
    - gender = Male/Female | ''
    - Birthdate = YYYY-MM-DDT00:00:00
    - Firstname = somename
    - Lastname = somename
    - countrycode = NN | ''
    - postalarea = someaddress | ''
    - streetname = somestreet | ''
    - zipcode = somezipcode | ''
    - employmentnumber = somenumber
    - positioncode = somenumber | ''
    - positionname = somename | ''
    - affiliation = some_organization_id
    """
    for person in person_list:
        ssn_not_valid = False
        valid_birthdate = True
        person_processed = {}

        logger.info("--- Processing employee number:%s ---",
                    person['EmploymentNumber'])

        #
        # Get Person Birthdate
        #
        try:
            person_processed.update({
                'birth_year': int(person['Birthdate'][0:4]),
                'birth_month': int(person['Birthdate'][5:7]),
                'birth_day': int(person['Birthdate'][8:10]),
            })
        except ValueError:
            valid_birthdate = False
            logger.warning("Empty Birthdate string for employee number:%s.",
                           person['EmploymentNumber'])

        #
        # check if SSN is registered and valid
        #
        try:
            fodselsnr.personnr_ok(person['Ssn'])
            person_processed['ssn'] = person['Ssn']
        except fodselsnr.InvalidFnrError:
            logger.warning("Empty SSN for employee number:%s",
                           person['EmploymentNumber'])
            ssn_not_valid = True
            person_processed['ssn'] = ''

        #
        # set person gender (checking both SSN and gender from sito input file)
        #
        gender = const.gender_male
        if not ssn_not_valid:
            if fodselsnr.er_kvinne(person['Ssn']):
                gender = const.gender_female
        elif gender != person['Gender'][0] == 'F':
            # ssn is not valid. use Gender variable from sito import file
            # instead.
            gender = const.gender_female
        else:
            # person has neither ssn nor gender set in import file. impossible
            # to set gender.
            logger.warning("impossible to set gender for employee number:%s."
                           " using Unknown", person['EmploymentNumber'])
            gender = const.gender_unknown

        person_processed['gender'] = gender

        #
        # Validate Birthdate against SSN
        #
        if not ssn_not_valid and valid_birthdate:
            (year_check,
             month_check,
             day_check) = fodselsnr.fodt_dato(person['Ssn'])
            # person has ssn and birthdate. verify the data
            if year_check != person_processed['birth_year']:
                logger.warn("Year inconsistent between XML (%s) and FNR (%s) "
                            "for employee:%s", person_processed['birth_year'],
                            year_check, person['EmploymentNumber'])
                continue
            if month_check != person_processed['birth_month']:
                logger.warn("Month inconsistent between XML (%s) and FNR (%s) "
                            "for employee %s", person_processed['birth_month'],
                            month_check, person['EmploymentNumber'])
                continue
            if day_check != person_processed['birth_day']:
                logger.warn("Day inconsistent between XML (%s) and FNR (%s) "
                            "for person %s", person_processed['birth_day'],
                            day_check, person['EmploymentNumber'])
                continue
        elif not ssn_not_valid and not valid_birthdate:
            # person has ssn but not birthdate. set birthdate based on ssn.
            logger.warn("person:%s is missing birthdate. Setting it based "
                        "on SSN", person['Ssn'])
            if fodselsnr.personnr_ok(person['Ssn']):
                year, mon, day = fodselsnr.fodt_dato(person['Ssn'])
                person_processed.update({
                    'birth_year':  year,
                    'birth_month':  mon,
                    'birth_day':  day,
                })
            else:
                continue

        elif valid_birthdate and ssn_not_valid:
            # person have birthdate but NOT ssn. Nothing to do here
            pass

        elif not valid_birthdate and ssn_not_valid:
            # person does not have birthdate nor ssn. This person cannot be
            # built.  SSN or Birthdate required. Return error message and
            # continue with NEXT person
            logger.warn("Employee number: %s is missing SSN and Birthdate. "
                        "NOT imported", person['EmploymentNumber'])
            continue

        #################################################
        # collect various person data from person list  #
        #################################################

        person_processed.update({
            'ansattnr': person['EmploymentNumber'],
            'Firstname': person['Firstname'],
            'Lastname': person['Lastname'],
            'PositionName': person['PositionName'],
            'title': person['title'],
        })
        if 'Middlename' in person:
            person_processed['Middlename'] = person['Middlename']

        #
        # Get person object som DB if it exists
        #

        new_person.clear()
        try:
            new_person.find_by_external_id(const.externalid_sito_ansattnr,
                                           person_processed['ansattnr'])
        except Errors.NotFoundError:
            # could not find person in DB based on ansattnr.
            if not ssn_not_valid:
                # try to find person using ssn if ssn is valid
                try:
                    new_person.clear()
                    new_person.find_by_external_id(const.externalid_fodselsnr,
                                                   person_processed['ssn'])
                except Errors.NotFoundError:
                    # Could not find person in DB based on fnr
                    logger.info("-- Create new person object for ssn:%s --",
                                person_processed['ssn'])
                    pass

        if (person_processed['Firstname'].isspace() or
                person_processed['Lastname'].isspace()):
            # Firstname and/or lastname is made of whitespace ONLY.
            # generate error message and continue with NEXT person
            logger.error("missing first and/or lastname for person:%s. "
                         "Person NOT imported", person)
            continue

        #
        # Populate the person object
        #
        try:
            new_person.populate(
                mx.DateTime.Date(person_processed['birth_year'],
                                 person_processed['birth_month'],
                                 person_processed['birth_day']),
                gender)
        except Errors.CerebrumError as m:
            logger.error("Person: %s populate failed: %s",
                         person_processed['ssn'] or
                         person_processed['ansattnr'], m)
            # population of person object failes. Continue
            continue
        new_person.affect_names(const.system_sito, const.name_first,
                                const.name_last, const.name_work_title)
        new_person.affect_external_id(const.system_sito,
                                      const.externalid_fodselsnr,
                                      const.externalid_sito_ansattnr)
        try:
            person_processed['Middlename']
            concat_firstname = "%s %s" % (person_processed['Firstname'],
                                          person_processed['Middlename'])
            person_processed['Firstname'] = concat_firstname
            logger.debug("CONCAT FIRSTNAME:%s", person_processed['Firstname'])
        except KeyError:
            # person has no middlename. use original firstname
            pass
        new_person.populate_name(const.name_first,
                                 person_processed['Firstname'])
        new_person.populate_name(const.name_last, person_processed['Lastname'])

        logger.warning("person_processed title is:%s",
                       person_processed['title'])
        if person_processed['title'] != '':
            new_person.populate_name(const.name_work_title,
                                     person_processed['title'])
        if person_processed['ssn'] != '':
            new_person.populate_external_id(const.system_sito,
                                            const.externalid_fodselsnr,
                                            person_processed['ssn'])
            logger.info("setting external_id to:%s", person_processed['ssn'])
        new_person.populate_external_id(const.system_sito,
                                        const.externalid_sito_ansattnr,
                                        person_processed['ansattnr'])

        # In case this is a new person, we will need to write to DB before we
        # can continue.
        new_person.write_db()

        affiliation = determine_affiliations(person)
        new_person.populate_affiliation(const.system_sito)
        contact = determine_contact(person)
        new_person.populate_contact_info(const.system_sito)

        # set person affiliation
        for k, v in affiliation.items():
            ou_id, aff, aff_stat = v
            logger.info("Has affiliation %s towards ou:%s", aff_stat, ou_id)
            new_person.populate_affiliation(const.system_sito, ou_id,
                                            int(aff), int(aff_stat))

            # set this persons affiliation entry to False
            # this ensures that this persons affiliations will not be removed
            # when the clean_affiliation function is called after import person
            if k in cere_list:
                cere_list[k] = False

        # get person work, cellular and home phone numbers
        c_prefs = {}
        for con, number in contact.items():
            if con == 'Cellphone':
                c_type = int(const.contact_mobile_phone)
            if con == 'Home':
                c_type = int(const.contact_phone_private)
            if con == 'Work':
                c_type = int(const.contact_phone)
            pref = c_prefs.get(c_type, 0)
            new_person.populate_contact_info(const.system_sito, c_type, number,
                                             pref)
            logger.debug("system:%s, c_type:%s, number:%s, pref:%s",
                         const.system_sito, c_type, number, pref)
            pref = c_prefs[c_type] = pref = 1

        op2 = new_person.write_db()
        logger.info("WriteDB after affs: %s" % (op2,))


def determine_contact(person):
    phone_info = {}
    phone = string.split(person['Phone'], ',')
    for single_phone in phone:
        single_phone = single_phone.strip()
        if(len(single_phone) > 0):
            # append each phone type to returning object
            type, number = single_phone.split(":")
            phone_info[type] = number
    return phone_info


#
# Get ou_id based on external_id
#
def get_ou(a, person):

    external_id = a.split(",")

    for single_id in external_id:
        ou.clear()
        try:
            ou.find_by_external_id(id_type=const.externalid_sito_ou,
                                   external_id=single_id,
                                   source_system=const.system_sito,
                                   entity_type=const.entity_ou)
        except EntityExpiredError:
            # person registered to expired OU. return error message.
            logger.error("person:%s is registered to expired OU "
                         "with external_id:%s", person['Ssn'], single_id)
            return -1
        except Errors.NotFoundError:
            logger.error("WARNING - person:%s %s is registered to a "
                         "nonexisting OU with external id:%s",
                         person['Firstname'], person['Lastname'], single_id)
            return -1

        if single_id == cereconf.DEFAULT_SITO_ROOT_HASH:
            logger.info("person:%s has affiliation to SITO root node",
                        person['Ssn'])
        return ou.entity_id


#
# will return a list of:
# ou_id              - organizational ID
# affiliation        - Ansatt
# affiliation type   - (tekadn,adm)
#
# For all person affiliations
#
def determine_affiliations(person):
    ret = {}
    # percentage = []
    aff = const.affiliation_ansatt_sito
    aff_stat = ''
    t = person['Affiliation'].split(",")
    for a in t:
        # position_type = person['Employment_description']
        person['Employment_description']
        aff_stat = const.affiliation_status_ansatt_sito
        ou = get_ou(a, person)
        if ou == -1:
            # unable to find OU.
            logger.error("Got -1 from get_ou %s", a)
            continue
        else:
            # valid ou id found. continue processing
            k = "%s:%s:%s" % (new_person.entity_id, ou, int(aff))
            if k not in ret:
                ret[k] = (ou, const.affiliation_ansatt_sito, aff_stat)
    return ret


#
# Generate person data from SITO person file.
#
# Required attributes are (withouth these person will not be imported):
#
#   SSN
#   EmploymentNumber
#   Firstname
#   Lastname
#   Affiliation
#   IsDeactivated
#
def generate_person_list(personfile, person_list):

    if not os.path.isfile(personfile):
        logger.error("File:%s does not exist. Exiting", personfile)
        sys.exit(1)

    datafile = libxml2.parseFile(personfile)
    ctxt = datafile.xpathNewContext()

    #
    # Parse person xml file and get all relevant person data
    #
    for person in ctxt.xpathEval("//Persons/Person"):
        person_dict = {}
        ctxt.setContextNode(person)

        #
        # Get Person data from person xml file. In cases where data is missing
        # the relevant person_dict['somename'] value will be set to an empty
        # string
        #
        try:
            person_dict['EmploymentNumber'] = ctxt.xpathEval(
                'EmploymentInfo/Employee/EmployeeNumber')[0].getContent()
        except IndexError:
            # person does not have an EmploymentNumer. Generate error message
            # and continue with NEXT person.
            logger.warn("person:%s does NOT have an EmploymentNumber. "
                        "Person NOT processed", person_dict)
            continue

        try:
            person_dict['Ssn'] = ctxt.xpathEval(
                'SocialSecurityNumber')[0].getContent()
        except IndexError:
            # person does not have ssn.
            person_dict['Ssn'] = ''

        try:
            person_dict['Gender'] = ctxt.xpathEval('Gender')[0].getContent()
        except IndexError:
            # person does not have Gender set. This is not a problem.  A check
            # of the persons SSN later in the code will reveal person gender
            person_dict['Gender'] = ''

        try:
            person_dict['Birthdate'] = ctxt.xpathEval(
                'BirthDate')[0].getContent()
        except IndexError:
            # person does not have Birthday set. This is not a problem. A check
            # of the persons SSN later in the code will reveal person birthdate
            person_dict['Birthdate'] = ''

        try:
            person_dict['Firstname'] = ctxt.xpathEval(
                'FirstName')[0].getContent()
        except IndexError:
            # This is not allowed. a Person MUST have a first name.
            # generate error message and continue with next person
            logger.warn("employee number %s is missing firstname in sito XML. "
                        "person NOT processed",
                        person_dict['EmploymentNumber'])
            continue

        try:
            person_dict['Middlename'] = ctxt.xpathEval(
                'MiddleName')[0].getContent()
            logger.debug("collected middlename:%s", person_dict['Middlename'])
        except IndexError:
            # this person has no middle name. do nothing
            pass

        try:
            person_dict['Lastname'] = ctxt.xpathEval(
                'LastName')[0].getContent()
        except IndexError:
            # person does not have a lastname.
            # Generate warning message and continue with NEXT person
            logger.warn("Employee:%s is missing LASTNAME in sito xml. "
                        "person NOT processed",
                        person_dict['EmploymentNumber'])
            continue

        try:
            person_dict['Countrycode'] = ctxt.xpathEval(
                'CountryCode')[0].getContent()
        except IndexError:
            # person is missing country code. Generate warning message and
            # continue
            logger.warn("Employee:%s is missing country code in sito xml",
                        person_dict['EmploymentNumber'])
            person_dict['Countrycode'] = ''

        try:
            person_dict['Postalarea'] = ctxt.xpathEval(
                'Addresses/Address/PostalArea')[0].getContent()
        except IndexError:
            # person is missing postalarea code. Generate warning message and
            # continue
            logger.warning("Employee:%s is missing postalarea code in sito "
                           "xml", person_dict['EmploymentNumber'])
            person_dict['Postalarea'] = ''

        try:
            person_dict['Streetname'] = ctxt.xpathEval(
                'Addresses/Address/StreetName1')[0].getContent()
        except IndexError:
            # person is missing streetname. generat warning message and
            # continue
            logger.warning("Employee:%s is missing streetname in sito xml",
                           person_dict['EmploymentNumber'])
            person_dict['Streetname'] = ''

        try:
            person_dict['Zipcode'] = ctxt.xpathEval(
                'Addresses/Address/ZipCode')[0].getContent()
        except IndexError:
            # person does not have a zipcode. generate warning message and
            # continue
            logger.warning("employee number:%s does not have zipcode in "
                           "sito xml", person_dict['EmploymentNumber'])
            person_dict['Zipcode'] = ''

        try:
            person_dict['PositionCode'] = ctxt.xpathEval(
                'EmploymentInfo/Employee/Employment/'
                'Employment/Position/SsbCode')[0].getContent()
        except IndexError:
            # person does not have a PositionCode in sito xml. generate warning
            # message and continue
            logger.warning("Employee:%s does not have a PositionCode in sito "
                           "xml", person_dict['EmploymentNumber'])
            person_dict['PositionCode'] = ''

        try:
            person_dict['PositionName'] = ctxt.xpathEval(
                'EmploymentInfo/Employee/Employment/'
                'Employment/Position/SsbName')[0].getContent()
        except IndexError:
            # person doest not have a PositionName in sito xml. Generate
            # warning message and continue
            logger.warning("Employee: %s does not have a positionname in sito "
                           "xml.", person_dict['EmploymentNumber'])
            person_dict['PositionName'] = ''

        afflist = list()
        try:
            person_dict['isDeactivated'] = ctxt.xpathEval(
                'IsDeactivated')[0].getContent()
        except IndexError:
            # No IsDeactivated tag on person object. Return error message and
            # continue
            logger.warn("Person:%s does not have IsDeactivated tag. Person "
                        "NOT processed", person_dict['EmploymentNumber'])
            continue
        try:
            person_dict['Employment_description'] = ctxt.xpathEval(
                'EmploymentInfo/Employee/Employment/'
                'Employment/Category/Name')[0].getContent()
        except IndexError:
            # No category name variable. does person have any affiliations at
            # all?
            person_dict['Employment_description'] = ''
            logger.warning("Employee:%s does not have any employment "
                           "description name", person_dict['EmploymentNumber'])
        try:
            person_dict['Email'] = ctxt.xpathEval(
                'EMailAddresses/EMailAddress/Address')[0].getContent()
        except IndexError:
            # Person does not have email address
            logger.warning("EMployee:%s does not have a registered email"
                           " address", person_dict['EmploymentNumber'])

        logger.debug("---- SSN ----:%s", person_dict['Ssn'])

        # need to get all affiliations for this person
        for aff in person.xpathEval(
                'EmploymentInfo/Employee/Employment/Employment'):
            unit = aff.xpathEval(
                'EmploymentDistributionList/EmploymentDistribution/'
                'Unit/Value')[0].getContent()
            from_date = aff.xpathEval('FromDate')[0].getContent()
            to_date = aff.xpathEval('ToDate')[0].getContent()

            # convert dates so they are easier to compare
            today_conv = "%s%s%s" % (TODAY[0:4], TODAY[5:7], TODAY[8:10])
            try:
                from_date_conv = "%s%s%s" % (from_date[0:4], from_date[5:7],
                                             from_date[8:10])
            except:
                logger.debug("\t has no from date")

            try:
                to_date_conv = "%s%s%s" % (to_date[0:4], to_date[5:7],
                                           to_date[8:10])
            except:
                logger.debug("\t has no To date")

            try:
                title = aff.xpathEval('Position/Name')[0].getContent()
            except:
                logger.info("Unable to get title for unit:%s", unit)
            if to_date != '':
                if from_date_conv <= today_conv < to_date_conv:
                    logger.debug("\t Today %s is in range from:%s to:%s",
                                 today_conv, from_date_conv, to_date_conv)
                    logger.debug("\t appending: %s to aff_list", unit)
                    if unit not in afflist:
                        afflist.append(unit)
                        try:
                            person_dict['title'] = title
                            logger.info("setting title to :%s",
                                        person_dict['title'])
                        except Exception:
                            logger.info("Unable to get title for position:%s",
                                        unit)
                    else:
                        logger.debug("\t %s is already in this list", unit)
                else:
                    logger.debug("\t Today:%s is NOT in range from:%s to:%s",
                                 today_conv, from_date_conv, to_date_conv)
                    logger.debug("\t NOT appending this affiliation. it is "
                                 "out of date.")
            if to_date == '':
                if from_date_conv <= today_conv:
                    logger.debug("\t Today:%s is in range from:%s to:infinite",
                                 today_conv, from_date_conv)
                    logger.debug("\t appending: %s to aff_list", unit)
                    if unit not in afflist:
                        logger.debug("I am actually appending ")
                        afflist.append(unit)
                        try:
                            person_dict['title'] = title
                            logger.info("setting title to :%s",
                                        person_dict['title'])
                        except:
                            logger.info("Unable to get title for position:%s",
                                        unit)
                    else:
                        logger.debug("\t %s is already in this list" % (unit))
                else:
                    logger.debug("\t NOT appending this affiliation. it is "
                                 "out of date.")
            if len(afflist) > 0:
                person_dict['Affiliation'] = ",".join(afflist)

        #
        # if a person has no active affiliations. continue with next person
        #
        try:
            person_dict['Affiliation']
        except KeyError:
            logger.debug("ssn:%s has no active affiliations",
                         person_dict['Ssn'])
            continue

        # get all phone numbers
        person_dict['Phone'] = ''
        try:
            for phone in person.xpathEval('Phones/Phone'):
                p_type = phone.xpathEval('Type')[0].getContent()
                p_number = phone.xpathEval('Number')[0].getContent()

                if p_type == 'CellPhone':
                    person_dict['Phone'] += ",Cellphone:%s" % p_number
                elif p_type == 'Home':
                    person_dict['Phone'] += ",Home:%s" % p_number
                elif p_type == 'DirectNumber':
                    person_dict['Phone'] += ",Work:%s" % p_number
        except IndexError:
            # person does not have a registered phone number. Do nothing.
            pass
        if person_dict['isDeactivated'] == 'false':
            person_list.append(person_dict)
    return person_list


#
# imports OU data from SITO
#
def generate_ou_list(datafile):

    if not os.path.isfile(datafile):
        logger.error("file:%s doest not exist. Exiting" % datafile)
        sys.exit(1)

    ou_list = []

    datafile = libxml2.parseFile(datafile)
    ctxt = datafile.xpathNewContext()

    for unit in ctxt.xpathEval("//Units/Unit"):
        ou_dir = {}
        ctxt.setContextNode(unit)
        ou_dir['unit_id'] = ctxt.xpathEval(
            './InternalInfo/Guid')[0].getContent()
        ou_dir['Name'] = ctxt.xpathEval(
            './Name')[0].getContent()
        ou_dir['ID'] = ctxt.xpathEval(
            './InternalInfo/Guid')[0].getContent()
        ou_dir['IsDeactivated'] = ctxt.xpathEval(
            './IsDeactivated')[0].getContent()
        try:
            ou_dir['ParentID'] = ctxt.xpathEval(
                './ParentUnitIdentifier/Value')[0].getContent()
        except IndexError:
            # not all ou's have a parent ou. continue generating
            # the list even if this parameter is missing.
            pass
        if ou_dir['IsDeactivated'] == 'false':
            ou_list.append(dict(ou_dir))

    return ou_list


#
# Stupid libxml2 insists on returning utf-8 encoded text.
# This function converts utf-8 to is-8859-1 so the text
# can propperly be stored in the database
#
def encode_decode_text(list, type):
    if type == 'OU':
        for ou in list:
            new_name = unicode(ou['Name'], 'utf-8')
            ou['Name'] = new_name
    elif type == 'Person':
        for person in list:
            new_firstname = unicode(person['Firstname'], 'utf-8')
            try:
                person['Middlename']
                new_middlename = unicode(person['Middlename'], 'utf-8')
                person['Middlename'] = new_middlename
            except KeyError:
                # person has no middlename, do nothing
                pass

            new_lastname = unicode(person['Lastname'], 'utf-8')
            new_positionname = unicode(person['PositionName'], 'utf-8')
            new_title = unicode(person['title'], 'utf-8')
            person['Firstname'] = new_firstname
            person['Lastname'] = new_lastname
            person['PositionName'] = new_positionname
            person['title'] = new_title
    return list


# KEB
# ou.populate() no longer sets name, acronym, short_name, display_name or
# sort_name this must handled with add_name_with_language()

def populate_the_rest(name, acronym, short_name, display_name, sort_name):
    name_language = const.language_nb
    ou.add_name_with_language(const.ou_name, name_language, name)
    ou.add_name_with_language(const.ou_name_acronym, name_language, acronym)
    ou.add_name_with_language(const.ou_name_short, name_language, short_name)
    ou.add_name_with_language(const.ou_name_display, name_language,
                              display_name)
    # TODO: don't know what to do with sort_name, ignoring it for now.


def import_ou(ou_list, dryrun):
    # get sito ou's from BAS
    expire_list = None
    parent_list = []
    perspective = getattr(const, "perspective_sito")
    all = ou.list_all_with_perspective(perspective)  # also expired ou's

    try:
        expire_list = list(all)
    except TypeError:
        logger.warning("no ou's in bas with perspective perspective_sito")
        return -1
    #
    # insert or update SITO ou's in BAS
    #
    for sito_ou in ou_list:
        if(sito_ou['IsDeactivated'] == 'false'):
            logger.debug("--- Proccessing ou from ou file ---")
            # clear ou structure
            ou.clear()
            new_ou = False
            #
            # find ou in database if it already exists
            #
            try:
                ou.find_by_external_id(id_type=const.externalid_sito_ou,
                                       external_id=sito_ou['unit_id'],
                                       source_system=const.system_sito,
                                       entity_type=const.externalid_sito_ou)
            except Errors.NotFoundError:
                # New ou.
                logger.info("new OU [%s, %s, %s] ", sito_ou['Name'],
                            sito_ou['unit_id'], sito_ou['IsDeactivated'])
                ou.populate()
                ou.write_db()
                populate_the_rest(sito_ou['Name'], sito_ou['Name'],
                                  sito_ou['Name'], sito_ou['Name'], 1)
                ou.write_db()
                ou.affect_external_id(const.system_sito,
                                      const.externalid_sito_ou)
                ou.populate_external_id(source_system=const.system_sito,
                                        id_type=const.externalid_sito_ou,
                                        external_id=sito_ou['unit_id'])
                ou.write_db()
                new_ou = True

            except EntityExpiredError as m:
                # ou is marked as active in import file, but inactive in
                # database.
                # remove expire date from database
                # HACK: in order to get the ou_id of the expired ou we turn to
                # some ugly string operations.  This because we want to remove
                # the expire date on the ou being processed.
                tmp_str = str(m)
                tmps = tmp_str.find(" ")
                tmps2 = tmp_str.rfind(" ")
                entity_id = tmp_str[tmps:tmps2]
                logger.warning("ReActivating OU, Removing expire date "
                               "for ou_id:%s", entity_id)

                e = EntityExpire(db)
                e.find(entity_id, expired_before="1970-01-01")  # linux epoch
                e._delete_expire_date()
                e.write_db()
                if not dryrun:
                    e.commit()
                e.clear()
                ou.clear()
                ou.find_by_external_id(id_type=const.externalid_sito_ou,
                                       external_id=sito_ou['unit_id'],
                                       source_system=const.system_sito,
                                       entity_type=const.externalid_sito_ou)
            else:
                # Found old ou. Overwrite old data.
                pass

            #
            # populate OU structure. If it was "found" above, the old
            # information will be overwritten
            #
            if not new_ou:
                logger.info("DepartmentID:%s already has entity_id:%s.",
                            sito_ou['unit_id'], ou.entity_id)
                ou.populate()
                populate_the_rest(sito_ou['Name'], sito_ou['Name'],
                                  sito_ou['Name'], sito_ou['Name'], 1)
                ou.write_db()

            #
            # Create ou structure
            #
            found_parent = False
            for i in ou_list:
                parentid = {}
                try:
                    if sito_ou['ParentID'] == i['ID']:
                        parentid = {
                            'child': sito_ou['unit_id'],
                            'parent': i['unit_id'],
                        }
                        parent_list.append(parentid)
                        found_parent = True
                        break
                except:
                    pass

            if not found_parent:
                # ou has no parent, set parentID to 0 (root node)
                parentid = {
                    'child': sito_ou['unit_id'],
                    'parent': '0',
                }
                parent_list.append(parentid)

            #
            # Remove active OU's from ou expire list
            #
            if sito_ou['IsDeactivated'] == 'false':
                # remove ou from list of inactive ou's
                if len(expire_list) > 0:
                    for unit in expire_list:
                        if unit[0] == ou.entity_id:
                            expire_list.remove(unit)

    #
    # Need to commit to DB in order to set ou_structure
    # NOTE: we only commit if dryrun == False
    #
    if not dryrun:
        db.commit()
        logger.debug("Commit changes")

    #
    # Set parent for all ou's
    #
    for parent in parent_list:
        if(parent['parent'] == '0'):
            parent_entity_id = None
        else:
            ou.clear()
            try:
                ou.find_by_external_id(id_type=const.externalid_sito_ou,
                                       external_id=parent['parent'],
                                       source_system=const.system_sito,
                                       entity_type=const.entity_ou)
                parent_entity_id = ou.entity_id
                ou.clear()
            except Errors.NotFoundError:
                # unable to find parent ou. Lets hope this is the root node.
                continue
        try:
            ou.clear()
            ou.find_by_external_id(id_type=const.externalid_sito_ou,
                                   external_id=parent['child'],
                                   source_system=const.system_sito,
                                   entity_type=const.externalid_sito_ou)

        except Errors.NotFoundError:
            # unable to find child ou. This is fatal error.
            logger.error("UNABLE to find child ou with external id:%s",
                         parent['child'])

        #
        # At this point parent entity_id is stored in parent_entity_id  (if it
        # exists) ou class should contain a child of mentioned parent_entity_id
        #
        ou.set_parent(const.perspective_sito, parent_entity_id)
        ou.write_db()

    #
    # Set expire date on ou's missing from import file, or has set
    # IsDeactivated = true
    #

    try:
        for expired_ou in expire_list:
            ou.clear()
            try:
                ou.find(expired_ou[0])
            except EntityExpiredError:
                # This ou has already expired. Do nothing
                pass
            else:
                # This ou is expired in input file, but
                # active in DB. set expire_date in DB
                ou.write_db()
    except TypeError:
        logger.warning("cannot set expire date from empty list")


def usage(exitcode=0, msg=None):
    if msg:
        print(msg)
    print(__doc__)
    sys.exit(exitcode)


def main():
    global cere_list
    personfile = '/cerebrum/var/dumps/sito/gjeldende_person'
    oufile = '/cerebrum/var/dumps/sito/gjeldende_unit'
    execute_ou = False
    execute_person = False
    dryrun = False
    logger = Factory.get_logger('console')
    person_list = []
    try:
        opts, args = getopt.getopt(
            sys.argv[1:],
            'p:o:dh',
            ['person_file=', 'ou_file=', 'dryrun', 'help'])
    except getopt.GetoptError as m:
        usage(1, m)

    for opt, val in opts:
        if opt in('-p', '--person_file'):
            execute_person = True
            input_personfile = val
        elif opt in ('-o', '--ou_file'):
            execute_ou = True
            input_oufile = val
        elif opt in ('-d', '--dryrun'):
            dryrun = True
        elif opt in ('-h', '--help'):
            usage()
        else:
            usage()

    if execute_person:
        personfile = input_personfile
    if execute_ou:
        oufile = input_oufile

    # only execute ou processing if no parameters are given, or if only the ou
    # parameter is given
    #
    if (((execute_ou is True) and (execute_person is False)) or
            ((execute_ou is False) and (execute_person is False))):
        logger.info("\t ## Generating OU list ##")
        ou_list = generate_ou_list(oufile)
        logger.info("\t ## OU list finished ##")

        logger.info("\t ## decode/encode text in OU list ##")
        ou_list = encode_decode_text(ou_list, 'OU')
        logger.info("\t ## decode/encode finished ##")

        logger.info("\t ## Import OU ##")
        import_ou(ou_list, dryrun)
        logger.info("\t ## OU import finished ##")

    # Only execute person processing if no parameters are given, or if only the
    # person parameter is given.
    #
    if (((execute_ou is False) and (execute_person is True)) or
            ((execute_ou is False) and (execute_person is False))):

        logger.info("\t ## Generate list of all sito person affiliations ##")
        cere_list = load_all_affi_entry()
        logger.info("\t ## Done ## ")

        # create a list of all sito person affiliations
        logger.info("\t ## Generate Person list ##")
        person_list = generate_person_list(personfile, person_list)
        logger.info("\t ## Person list finished")

        logger.info("\t ## decode/encode person names##")
        person_list = encode_decode_text(person_list, 'Person')
        logger.info("\t ## decode/encode finished##")

        logger.info("\t ## Import person ##")
        import_person(person_list)
        logger.info("\t ## Person import finished ##")

        # remove any person affiliations set as "not False" in cere_list
        logger.info("\t ## Removing expired person affiliations ##")
        clean_affi_s_list()
        logger.info("\t ## Old affiliations removed ##")

    #
    # Commit to DB if dryrun flag is set to False, otherwise rollback changes
    #
    if dryrun:
        db.rollback()
        logger.warning("\t ## Dryrun: NOT commiting to DB ##")
    else:
        logger.info("\t ## commiting to DB ##")
        db.commit()


if __name__ == '__main__':
    main()
